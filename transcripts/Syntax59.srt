1
00:00:00,359 --> 00:00:24,480
Announcer: Monday Monday Monday open wide dev fans yet ready to stuff your face with JavaScript CSS node modules, barbecue tip workflow breakdancing soft skill web development hasty as crazy as tasty as web development treats coming in hot here is Sarah CUDA. And Scott. Totally ski.

2
00:00:25,950 --> 00:00:58,440
Scott Tolinski: Oh, Welcome. Welcome. Welcome to Monday's edition of syntax which is we like to call a hasty treat with me as always, is Wes Barracuda boss. My name is Scott El Toro loco to linskey I hope you liked the new tasty intro that we cooked up for you because we love it. In fact, we were probably both in tears when we were listening to that the first time when we were just even describing it to each other. I think we were we were losing it. So I hope you like the Mondays. Yeah,

3
00:00:58,470 --> 00:01:22,410
Wes Bos: we were making the script so that the that intro that we have was like we went on Fiverr and found some guy that does like radio for 17 bucks. We got that guy to record that intro and we came up with the names and we looked at monster truck names and West Barracuda boss just came to me but then we found Scott El Toro Lin's linski with tillet skia which is means crazy crazy bull.

4
00:01:22,620 --> 00:04:57,380
Scott Tolinski: Yeah, yeah, the crazy ball. Yeah, the crazy. Yeah. And it's a really cool monster truck too. So check it out. That is a really cool monster truck. I didn't want to be Grave Digger. It's a little too aggressive. And I like the alliteration of, you know, well, I guess it's not necessary alliteration. But I like the, you know, Torah polinsky a lot of T's that's hard T's coming in there. like that a lot. So our sponsor for this episode is Netlify. And if you've been listening to this podcast for any bit of time, you know how much we love Netlify Netlify is a great place to build, deploy, manage modern web projects. I'm a huge fan of this service people always you'll see tweets nonstop. They'll say, Man, Scott really likes to talk about Netlify. And then I actually used it, and the Holy cow, you were not kidding. People say that all the time. Seriously, maybe like every day, we get a message from somebody who had never tried Netlify before they try it. And they're just so impressed with the initial setup process that they cannot wait to tweet about it. Because it's that awesome. It's very tweetable. I myself, the first time I used it tweeted about it. And I was just so excited about how cool this service is. Basically Netlify makes deploying your front end code as simple as possible. But more than just deploying your front end code, it also gives you access to all sorts of stuff that you might miss. If you were running a front end project without a server, right, you get access to contact forms, you get access to authentication, you get access to serverless functions, all built into this platform that makes it as easy as possible for you. That's the thing that really, really stands out to me about Netlify is just how easy they make everything. I mean, for instance, you you basically push a couple of buttons, your site's live, you get automatic continuous deployment, no more install scripts, or setup or anything like that. You get automatic continuous deployment from a repo you had access to obviously custom domain names were nice and easy to add a domain name, just point your DNS on over. One of the absolute best features about Netlify is their automatic HTTPS, every single new site that gets put up is automatically going to have an SSL certificate, no clicks necessary. How cool is that? In this time and era, where everyone says, Hey, you need an SSL, and then you say, dang, working with SSL is is no fun. Well, they make it as easy as possible. No excuses. If you need an SSL certificate, this is the way to do it here on Netlify. Nice and easy. Not to mention, there's also some amazing AB testing stuff that just head to netlify.com forward slash syntax seriously, sign up, check it out, you are not going to regret that time spend because seriously, it's actually minimal time spent. And the results are just awesome. So Netlify is my new favorite host. They have been they have been since I very very first tried it. And I'm not going back. I'm such I'm sold on Netlify. It's one of my favorite platforms here. So this tasty treat is sponsored by Netlify. Again, netlify.com forward slash syntax or tweeted them let them know about Netlify. This episode today is all about refactoring in that refactoring is something that well we as developers have to face well all the time as you grow as a developer, or one of the things about refactoring is that when you look at code you wrote two years ago, you'll often want to hide from it. And refactoring code is the best way to learn a little bit about all of the stuff you have learned. So Wes, do you want to take a stab at what refactoring is? Exactly?

5
00:04:57,570 --> 00:06:06,900
Wes Bos: Yeah, so often you'll have a code base Your code works. But it's not the best code you've ever written. It's not the most flexible code you've ever written, maybe if you want to add stuff to your codebase, and it can't be done because of your existing code base, maybe it's using some out of date techniques, you've got just a whole bunch of reasons why you have a code base. And it's stopping you from being the best developer you can be whether it's just enjoying the code and working with it, or whether it's implementing new technical features that that's kind of a one on one part of what technical debt is, is where you've got this old code. And it's really stopping you from moving as fast as you could, could like to. So refactoring just takes code that you've written, and then you just rewrite that code to do the exact same thing on the front end. So your users might not necessarily see any sort of improvement on the front end. Unless you've refactor for speed sake, they may see sort of like a faster response times or something like that. But then that's ideal, because your application still does the exact same thing. But you know, and you can sleep well at night, knowing the code behind that is much more well written. Yeah,

6
00:06:06,900 --> 00:07:30,060
Scott Tolinski: yeah, I think that's a, those are great points. Because there's so many times when there's aspects of your project that you don't want to touch because of it's a mess, and I want to work on this. It's a mess, right? I don't want to do this. But if you were to take that time to refactor it, working on it from that point forward gets a lot a lot nicer. And I think the most important thing about this is like people maybe spend too much time trying to write the perfect code, right? Right out of the gate, when like, really, if you're writing code to make it work, you can always improve your code afterwards. And we're going to get into some tips about how exactly to do that. But the first code that you write is often just going to be the first way that your brain goes to solve a problem. And how many times in life is the first way you've ever figured something out the best way? I mean, not often, right. So so many times you solve something that seems like the best way at the time, and then looking back at it, and like a month later, maybe you have some new skills under your belt, maybe you've had some time to let it marinate a little bit, it's you know, cooking in, in the little marination going and then all of a sudden, you're like, Oh, I could be doing this this way. And then therefore you can improve that code. And maybe the second time you write it, it's going to be much better, maybe it's not even going to be perfect, then and you got to rewrite it again, eventually. But refactoring is really just taking these ideas that you had initially, and then reworking them to be just better for a whole host of reasons which we'll get into.

7
00:07:30,480 --> 00:08:21,870
Wes Bos: Let's talk a little bit about the benefits to refactoring I think one of the biggest benefits, there's a couple of we'll go through one of the biggest ones is that you you keep part of the code base in your head. So it can happen when you have a large application, there's going to be parts of your code base that you haven't touched in a year, two years, five years, possibly. And while it's good to have their they always been working, you likely have tests running against that code base, that's good. But it's kind of scary when there are parts of your code base where you don't really understand how it works or why it works or what's going on there. And I find it really helpful, at least in my own codebase to go to pieces of the application that I haven't touched in a while and just give them a quick scan over maybe refactor a couple of the functions that are in there, just so I understand. Okay, this is the process to to how this works. And you have a little bit of headspace on that area of your application.

8
00:08:22,050 --> 00:09:42,510
Scott Tolinski: Yeah, I bet without even looking, you could probably tell me, what areas of your codebase are the areas that are most scary to you right now. Because I think we all have these areas that haven't been touched in various points. And maybe maybe that's just it, maybe you just haven't gone over with your more modern learning or understanding of things. And maybe you can go ahead and hit those up and make that a better experience for you. So that's really some of the benefits. Another thing is keeping your code up to date with new standards. I mean, we we as react developers have experienced like several changes in how you write react from the initial react dot create class using mix ins, and all those things to now using the class syntax, so the functional state stateless components, and now using even more new things, like you know, state is equal to rather than throwing it in your constructor, I mean, there's all sorts of little things and that change in how we write our code all the time. And refactoring allows your code to stay up to date, there's nothing worse than opening up a react project that you haven't touched in a while and still seeing that react create class and then have to shift your brain over that way after not using that for so long. So by keeping this code up to date refactoring your frequently and and making sure your your code is modern, is going to make it working on it just that much better. Really.

9
00:09:42,650 --> 00:11:10,950
Wes Bos: Actually a perfect example of that is my own code base is getting refactored right now the specifically the player is getting refactored because I'm pretty happy with the player. But there's a couple little annoying things where I want to do a little bit better tracking of where you're at in terms of your videos. I want to do a little bit better tracking in terms of displaying that I want to do. There's a bug right now, but the full screen, where if you watch a video and you fullscreen it, and it flips over to the next one, it's a bug where it kicks you out. There's a bug with the Vimeo right now, where if you have Privacy Badger installed, so there's a couple of things and they've all been fixed. But before we could put implement those, what we did is we went back and refactor the entire player because it was on react dot create class, and it was working fine for about a year and a half. But then I started to get these aches and pains where I wanted to quickly add something and then I'm like, Oh, this thing is still react router to and create class. And I had to do that whole like mind switch to like, Oh, this is how that used to work and refactoring it both allowed me to get up to speed on on the entire application much more quickly. But it also allowed us to implement new features much more quickly, much more easily. And I know now that now that I've had this player for two or three years, I can I can foresee things that I would like to add in the next year or two. And then that, that's great, because I've I've thought about those in and I can sort of build it now thinking of the future.

10
00:11:11,040 --> 00:12:50,400
Scott Tolinski: Yeah, I mean, when you first build these things, you're building it with the visibility of someone who's never built this. Now you're going to rebuild it with the visibility of someone who's one built it, but also used it for a period of time. And that kind of visibility opens up so many doors to you and the type of approach that you're going to be taking to use. I mean, another reason why we or another benefit you could gain from refactoring here is performance enhancement right performance on your site, maybe when you wrote this code is fine. Like here, here's a perfect example. Okay, I had one of my resolvers. And one of my one of my graph, qL, resolvers, that was checking hitting the database every single time it was loading a user role in for let's say, if I was, like, I had a, like a tutorial listing, and I was importing the user, it was doing a separate database query to grab that user's role every single time, even though on the server side, I already had the up to date user object being already pulled from the database once. So Apollo engine opened my eyes to see, hey, I was doing an extra database call there. And therefore, I could rewrite that code where I already had access to the user to not do that extra database call, just grab the user information, apply any sort of permission stuff I need directly on it there and then return and so therefore, again, the user is not seeing any change there. In fact, the code change was pretty minimal itself. But I did get some extra performance because it was not hitting the database when it didn't need to. And therefore, again, just a really nice little benefit that you can get from really looking at your code a second time.

11
00:12:50,939 --> 00:14:15,570
Wes Bos: Let's switch over to a when to refactor. And I think I mean, you might be a little bit different on this, I tend to leave my stuff pretty long. Because generally my stuff works. And it's not causing me any trouble. And I've been am happy with it. And I'm able to fairly easily add new things to it if I want to. However, at a certain point, like we talked about with my player, it does need to be re factored. Because it's it's starting to stop you from moving as quickly as you want or adding the features that your users are asking for. So when should you refactor? I think my biggest one is when it's stopping you from progressing, or writing the best experience you can because there's a lot to say, for writing beautiful code. But at the end of the day, convincing your boss that I'd like to spend two weeks just making my code look nicer. And not actually selling more stuff or, or the bottom line of the business. They don't necessarily always care about what the code looks like, unless it's starting to inhibit your your selling of stuff or your how quickly you can move. So I think if you have to convince your boss, hey, I would like to spend some time on this you need to bit make a bit of a better use case for the code will be better is this will help us to move much more quickly. Or this will speed up the site 300 milliseconds, and that's going to have an impact on on the bottom line. Now I know you refactor like crazy. So let's hear from you.

12
00:14:15,689 --> 00:16:54,450
Scott Tolinski: Yeah, it is it's a problem. But I can afford to do that. Because Well, I work on this thing at all times, you know, nights, weekends, whatever. I work on this this site whenever I feel like it. Because Yeah, it's it's my baby. So I am constantly refactoring it. But I'm also using refactoring as a way to learn new things. So again, this is my project. I'm the core decision maker if I want to migrate the whole thing to Redux and then four months later migrated over to Apollo state link. I can do that. But it you know, that's not necessarily what I would recommend. For me. I think there there are some big things if things are getting left in the dust in your sight. And you know that next year, this thing is going to become a major Problem trying to get ahead of some of these things a little earlier. For instance, I'm not trying to necessarily migrate off of Meteor right now. But I'm trying to remove the amount of Meteor specific things in my site, because I foresee it to be a problem. So for me, it's not too difficult. I have graph qL setup, I have some legacy Meteor methods in the site. And I'm just migrating those over to graph qL a little bit as we go here. So for me, I can foresee these being a problem in the future, or something I don't want to deal with in the future. I have some stylists leftover in the site. Right now I'm just migrating it to styled components, you can do that fairly quickly by throwing it all in your global styled components, and then moving them out into component as you go. Again, I foresee some of these things being issues later down the line of whether they are support or whether they're going to confuse other people working on the site, or whether or not it's actually user bug facing issues, I actually just rewrote my player component as well, because I wanted to keep track of user duration, like how far if they completed a video or not wanted to keep track of which video they finished watching most recently, in their series, there's like so many things, and my current situation could not do any of those. So I rewrote the entire player, the entire player page, all those components. And the benefits out there was amazing. I mean, to me, that was added a major feature that my audience has been asking for for a long time. And that I didn't want to do, because I knew it was not going to be that pretty, I was gonna have to dive into some older code. So for me, I saw that that was one a code smell, I didn't want to touch it, but people had been asking for it. And it was going to be a feature that a lot of people would really enjoy. So that's what I chose to make that tip to refactor that component. I think that's really it. There's these like, sort of useless refactors that I do all the time. But there's also the big ones like that. Yeah.

13
00:16:55,410 --> 00:17:29,300
Wes Bos: One other tip I have is, when you're bringing someone new on to the team, it's likely or sometimes it's a good good time to quickly refactor specific parts of your application, because there may be some legacy code in there, there may be some ideas that you don't use anymore. And it's not worth having to get that person up to space and, and get them into that headspace of the way you used to do things versus the way you do it now. And before you cut that person loose on working on on that piece of the codebase. It might be worth upgrading and refactoring. Different parts of that. Yeah, any other ideas of when to refactor?

14
00:17:29,490 --> 00:18:33,860
Scott Tolinski: Yeah, here's the little one. For those of you are working in like a component based system, nice little refactor would be breaking something out into its own component, right? Maybe you're working on a component, and it started out, and this component was like, 30, lines long. And then all of a sudden, next thing, you know, the components, like 150 lines long or 200 lines long, and you're looking at this giant beast of a component. It's not difficult at that point, when your head's already in that space, breaks that stuff out, refactor it into smaller components. And you'll thank yourself later, because when you come back to this giant beast of a thing, you're going to be like, Oh, I don't want to touch this. But when it's a bunch of smaller things you're going to be much more interested in working on later on. So as you go, and you start to notice things getting a little unruly, tame that up thrown into new component, I prefer smaller components to larger components myself, so I'm never afraid. At any point, if I'm thinking to myself, hmm, is this a little bit too long? I'm always almost going to say, Okay, if I'm thinking about it being too long, it's probably too long. So let's break it up.

15
00:18:34,020 --> 00:18:56,360
Wes Bos: Yeah, I think one of the best ways you can tell a good developer is if you're building something, and you find yourself going, huh, I've done this a couple times, I've written this code a couple times, or we've done the same thing over and over again, that's likely a point where you need to stop drop and refactor that part and make a separate library or node module or something that does the the piece that you're trying to do.

16
00:18:56,700 --> 00:19:39,320
Scott Tolinski: Word. Okay, so we gone over a little bit of what it is when to do it. And some of the benefits, let's talk about your tips for refactoring what stuff that you like to do when you refactor. And I think the biggest thing here is one of the reasons why people always ask about like tests, like, what are the benefits of tests, let me tell you, refactoring is one of the biggest benefits of writing tests. Because if you have your entire code tested, and you know if it works or not, when you go to refactor your code, you're gonna know if the new code works as well, if you wrote good tests that is, so write your tests well in the beginning to account for what this thing needs to do. And then when you do your refactors, if your tests are passing, then that means your refactor is most likely successful. I

17
00:19:39,320 --> 00:21:05,430
Wes Bos: think that's one of the best arguments for writing in depth tests. because ideally will happen is that you will refactor part of your application you'll refactor how a function specifically works. And if your tests all pass or then you know that okay, I totally, like gutted the back end out of this thing, but it's still working as intended, and that was a successful refactor. There's also a tool that that Facebook has here. It's called code mod. I've actually never used it myself, just because I don't work on a code base that is so large. But I know that Facebook itself has something like 100,000 react components, like they've got thousands of developers writing react every single day. And when react makes a breaking change, like they were to deprecate one of their methods, or they were to change from create class to extends, then they can't manually go through, like 4050 70,000 components and migrate those things. So they've created this tool, it's called code mod. And what code model do is you can write these little mods and often the reacting low release of code mod with this to upgrade your code base. And it will automatically switch over your code from one syntax to another because that's sometimes that's all the all of it is, you're moving from a callback to a promise based function, or you're moving from create class to extends, and you can just automate that through your your many, many components. I can't imagine having many thousands of components though.

18
00:21:06,240 --> 00:21:18,990
Scott Tolinski: Yeah, code bound thing is interesting. I like this kind of thing. I again, I probably I would feel nervous running a code mod, but at the same time, you probably shouldn't if you wrote the mod correctly, but it's definitely a really cool little offer if

19
00:21:18,990 --> 00:21:20,730
Wes Bos: you have the right tests, right?

20
00:21:20,810 --> 00:24:08,490
Scott Tolinski: Yeah, if you have the right tests, right, yeah. But then also you keep in mind, your tests have to be right, you know, right. If you write bad tests, and you refactor, and all your tests are passing, you'd be like, Alright, I might go look up the site, nothing works. So yeah, so definitely, those are some some nice little things. Another tip for refactoring is use Git as an escape hatch. So you want to obviously branch off, look at previous versions of that file. If you've run into trouble, like maybe you branched off, you have this new file, you're gonna start tweaking it, and you tweak a little too hard, you tweak it so hard, you can't get back to where you were always you have the ability, it is so so easy in something like VS code, or just click that little magnifying glass in the top right, you see what the previous version of this file look like. And maybe the answers are right there about how used to have it or something like that. Or maybe perhaps you started a path and refactoring. And all of the sudden, you are too far gone, and this thing is broken, and you have to get out and go back to work. If you're doing this on some sort of main branch that you're on could become a big issue. So just use normal Git sort of branch off, do all your stuff there and then merge that code back in. So you don't run into any sort of issues where you're left with code that doesn't work, or you're stuck in any sort of way. So definitely use Git as an escape hatch for your refactoring. Another good tip for refactoring is to simply just break your code into smaller chunks. A lot of times when we're rewriting our code, you don't realize that maybe you are repeating yourself in different ways. Or maybe something could be written as a function that's reused here and there. And here. And there are a lot of times when I'm going to do a refactor, I look at my code very broadly. And I say, Hey, is there anything in here that could be broken out into a smaller reusable chunk? And is that going to help me at all in this code clarity? Is this code going to be nicer to look at? So that's one of the places that I look at first is just breaking things down into smaller chunks in for me is the one of the first places I look at when I'm looking at something unruly, is there something I can refactor out into its own thing, again, most likely what I mentioned with react components as well, but that that's pretty much it, refactor your code, write good tests. And I, to be honest, I think it's not surprising that I'm, like obsessed with refactoring my code, if you hear me talk about this stuff, and I have the ability to do so I understand if you don't, but I really think it is important to to relook at code that you wrote in the past and see if you can do it better. I've looked at stuff that oh, you know, it was 150 lines to do something I could do in a couple of lines, just because I had new abilities that I didn't have before or a new understanding about how to do things. So it's important to look at your own old code, if it's going to become code that you're currently working on.

21
00:24:08,820 --> 00:24:25,470
Wes Bos: That's my favorite when you your git commit is like a deleted 100 lines added seven. So good. Like, I just totally rewrote this thing so much simpler, it's gonna be so much easier to maintain. I dropped all of these additional dependencies and you just feel so much better about the codebase in general.

22
00:24:25,650 --> 00:24:37,260
Scott Tolinski: Yeah. When I really discovered MAP Reduce and filter and all those things. I had so many areas of my sights that the code just got better functional programming in general. But yeah, big big fan.

23
00:24:37,590 --> 00:24:50,220
Wes Bos: Yeah, that's, that's funny, actually, it's one of the things I keep hearing over and over people tweet tweet me being like, Hey, thanks for the episode. We did that episode. Let me find the episode number array methods, JavaScript array methods.

24
00:24:50,220 --> 00:24:52,110
Scott Tolinski: It was Episode 43

25
00:24:52,110 --> 00:25:26,370
Wes Bos: JavaScript array methods. That was like one of the very impactful episodes because people kept tweeting me like screaming shots of code they refactor where they had something that was so much more complicated. And once you really understand all of how to use all the array and object methods, I think your codebase will get them a lot cleaner. Absolutely. So check that one out. If you're interested in more like more of the how tos, this is sort of ideas of react refactoring. But if you want more like, nuts and bolts of refactoring, specifically JavaScript, check that one out word.

26
00:25:26,400 --> 00:25:36,660
Scott Tolinski: Yeah, absolutely. So I hope you enjoyed this hasty treat. We're gonna be doing these every Monday in case you haven't noticed by now. This is what the fourth hasty treat that we've done so far.

27
00:25:37,380 --> 00:25:37,920
Wes Bos: Like that. Yeah.

28
00:25:37,920 --> 00:26:01,920
Scott Tolinski: And we now have a fancy new intro. So yeah, expect these every Monday we're going to be doing a little hasty treats on all sorts of topics. If there's a topic in particular you think would be perfectly suited for a 20 minute 30 minute little bite size video or not video, his podcast here, hit us up, let us know kind of things you want to see. We're always looking for new ideas as well. So that's it. I don't have anything else. Do you have anything else? I

29
00:26:01,920 --> 00:26:23,340
Wes Bos: think that's it. I'm just looking at the potluck questions that we got here and I just saw one from JC Hiatt. Explain what packaging yarn lock files are, when Why were they introduced? What do they do blah, blah, blah, blah, blah, all that so I think that's gonna make that's not even a potluck episode that's going to be upgraded to a hasty treat. We could do a whole show on that.

30
00:26:23,370 --> 00:26:27,660
Scott Tolinski: Yeah, JC is upgrading our bodies and we're about to upgrade everyone's mind.

31
00:26:28,890 --> 00:26:32,790
Wes Bos: Wicked. Alright, I think that's it for today. Thanks so much for tuning in. And we'll catch you next time

32
00:26:32,910 --> 00:26:45,270
Scott Tolinski: later as head on over to syntax.fm for a full archive of all of our shows. And don't forget to subscribe in your podcast player or drop a review if you like this show.

