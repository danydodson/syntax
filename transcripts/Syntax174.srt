1
00:00:01,319 --> 00:00:02,820
Announcer: You're listening to syntax,

2
00:00:02,849 --> 00:00:09,600
Unknown: the podcast with the tastiest web development treats out there. strap yourself in and get ready. Here is Scott, ski and West

3
00:00:09,600 --> 00:00:10,860
boss. Oh, welcome

4
00:00:10,860 --> 00:01:00,360
Wes Bos: to syntax. This is the podcast with the tastiest web development treats. Today we're going to learn how to build an API. If I've actually built a handful of API's in the past and seems like almost every project that I work on has some sort of API endpoint that need to ping in order to upload data or to modify data or pull data back. So we're going to sort of step you through the ins and outs of creating an API, some of the questions you should ask. And I think like, just for beginners, a hard thing for people to understand is just the sort of mindspace of like, what's going on behind the scenes, especially if you're not a back end developer, you just for front end, you might not necessarily understand like what's happening. So even if you don't want to create your own API, this will be a helpful sort of primer on what's happening behind the scenes when you send off a request to that API,

5
00:01:00,569 --> 00:01:11,370
Scott Tolinski: like mindspace would be a good name for a social media website in the future where you just like, think about it, and then you're in that space mindspace. So hi, space.

6
00:01:11,370 --> 00:01:41,340
Wes Bos: I like it. I'm sure that's something already. Today, we are sponsored by century and sanity century does all of your error and exception tracking insanity is a structured content, CMS that we've got some kind of new updates about what they've been cranking out lately or what's to come. So we'll talk about them partway through the episode. My name is Wes Bos, I am a full stack developer from Canada. And with me, as always, is Scott to Lynskey. How you doing today, Scott? Hey,

7
00:01:41,370 --> 00:02:15,150
Scott Tolinski: I'm doing very tired. I'm very tired. The you know, Courtney went back to work. So yeah, this morning was was a little rough, getting everybody ready, and getting everybody where they need to go. But I'm sure you're very well aware of that. So yeah, no, I'm, I'm ready to go. I'm looking at this coffee, like it needs to hurry up and work a little bit better. But other than that, I'm feeling great. Gonna be recording a lot of tutorial content today and stuff. So gotta get juiced up. But yeah, ready to talk about some API's? Let's let's get into it. Alright, so

8
00:02:15,150 --> 00:04:30,020
Wes Bos: first thing we need to do is the question is how do you build an API from scratch? There's lots of generators out there. There's lots of like, kind of helpers out there, which are great, like something like Prisma, or I'm not sure what the other ones are off the top of my head. But generally, the way that those work is you create your content types, and they'll create all the, the crud, we'll use that word a lot in this podcast, crud means create, update, read and delete. Those are the four operations that you're generally doing when you are hitting an API. But we thought we'd sort of peel it back and just talk about like, how do you create an API from scratch, because sometimes you might just need one or two quick endpoints, you might have an existing database you might have, like, a lot of my sort of API work came from building server rendered websites. And then as you need it to add, add functionality or build something in react, you need it to be able to ping that database and ping that API, or to crud your data. So actually, maybe I should just run through sort of the headings that we have here. So you can know to expect so first is you need to choose an API type. And that's rest or graph qL, then you need to set up some sort of server, we'll go into what some possible options are there, you need to document the endpoints, this is probably the biggest part of it, you need to figure out how to name it, you need to figure out how to secure it, you need to figure out how to protect it from malicious and bad actors. You need to then actually write the we're gonna call them resolvers, which is or controllers often people call them that basically the work that needs to be done when when somebody hits that endpoint. And then finally, we'll end it off with some some helpful tools for writing an API endpoint. So first one is you need to choose an API type. There are like I don't know, what are the different types of API, the two big ones are rest, which is probably the most popular where you hit like a URL like donuts.com for slash flavors. And and that will bring you back a list of flavors, right? And you could also create flavors, or you could modify flavors. Or you could delete flavors from that endpoint. That's a REST API where you have all these different endpoints. And each of those endpoints do different things. The other type of popular API now is obviously graph qL, which you want to take a stab at what that is Scott?

9
00:04:30,060 --> 00:05:49,770
Scott Tolinski: Yeah. So instead of having an endpoint for each thing that you're expecting to get back, you have one endpoint. And so you connect once right, you connect via the single graph qL endpoint and instead of hitting a different URL to get a specific thing back, you just tell that endpoint in a graph qL query language, what exactly you want. And that way, the difference is really there is that a REST API is always going to sort of return the same kind If data if you give it the same sort of the endpoint with the same parameters, right, but whereas a graph qL query, even though if you only want a very specific amount of data, you just ask for that specific amount of data, rather than saying, Let's go back to the donuts example, right? You're hitting that doughnuts endpoint with a REST API, you're always going to get back the donuts information. But with the graph qL API, you you hit your endpoint, you say, Hey, give me the donuts. And maybe, maybe I want some flavors. And maybe I want some accessories, or what the, I don't know, they made out of flour, or whatever the the donuts made out of. And you can get all of that information directly from the graph qL endpoint just by asking for it. So yeah, the big difference is it's one endpoint, and you're asking for information rather than many endpoints. And that's like, I guess the big distinction.

10
00:05:49,890 --> 00:07:21,660
Wes Bos: Yeah, absolutely. Other types of endpoints or other type of API. In the past, we've had like XML endpoints. So that's actually why it that's why we have the word Ajax it means a synchronous JavaScript in the XML. And then there, I believe, there's also soap endpoints, which soap endpoints which are so sorry, sorry, soap API's, they would return XML, those are a thing of a past, unless you're working in sort of more mature industries as a nice way to put it, like banking, or, I don't know, like, a lot of the banking is the big one, where you're working with tech that's 1015 years old, and he just doesn't change and you have to work with things like that. So that's sort of where you need to go, I would think in I would think, like, my approach to this type of thing would probably be, if I'm using something that has graph qL, built in like a generator, I would just go for that. I don't think that you need to have a large project. But then then again, if I just have a simple, if I'm just cooking up like a simple little app for myself, I'm just gonna put in one or two endpoints, I don't need relational data. Now, I don't necessarily care about the the fields that I do and do not want. So it's pretty easy to move over from one to another. We'll talk about those resolvers in just a minute. So you could you could pick either one of those. But if you are planning on like a beefier, bigger application, I would probably go graph qL right out of the gate.

11
00:07:21,930 --> 00:07:47,270
Scott Tolinski: I personally Yeah, go graph QL. Just because because I've been working in it so much that I'm so much more comfortable right now just and I've grown accustomed to the the niceties that graph qL provides, being able to ask for that specific data and not having to worry about endpoints and any of that stuff. So I personally would grab graph qL, too, but only because I have that experience, and it's most likely what's going to be the fastest thing for me to work in right now.

12
00:07:47,640 --> 00:08:39,629
Wes Bos: Yeah, one more thing we should say about this idea of rest and graph qL is that these are not things that you NPM, install, graph qL NPM, install rest, these are rest and graph qL are more methodologies as to how do you approach and structure your thing. So it's not a piece of software that you go out and do it's just more of a way that you tackle things. And then you have to then go out and get and this is our next one, you have to go out and get some sort of server that is going to accept the requests. That's a REST API endpoint or graph qL requests, do the work and then send responses. So you can do this in any language out there. Obviously, Scott and I are both JavaScript developers. So I would probably reach for something like express what I personally run all of my own endpoints on. koa is, this seems to be a pretty popular one. I know Scott runs his on Meteor.

13
00:08:39,990 --> 00:09:14,820
Scott Tolinski: But actually, believe it or not, my API is in Express within Meteor, if that makes any sense. Oh, yeah. So before in the past, my API was all straight up Meteor. And what it was was this thing called mini Mongo where you had to publish data via MongoDB. And then you could access it on the front end. But now since I'm doing all my queries through Apollo, yeah, no, I basically I'm just running an express server that's connecting. And what Meteor is doing is allowing me access to some meteors other goodness in there. But the API itself is actually expressed, which is kind of interesting.

14
00:09:15,000 --> 00:10:06,630
Wes Bos: COA seems to be a pretty popular one for specifically creating API's. I've just never myself got into it. Because I've been so comfortable with Express and I've never really had too many issues with it. I've been I've been fairly happy with Co Op or not co with express all my life. But if you want to check that out, I think that's a pretty popular one as well. The thing about Xpress is that often you're going to need to reach for middlewares to do things like authentication or rate limiting or blacklisting. And the beauty of Express is that they're all for almost everything that you need. There's already a middleware, which is sort of like a plugin that someone has already written. That will just immediately add all of that functionality. To each of your requests, and you don't have to do the heavy lifting, heavy lifting for yourself. Totally.

15
00:10:06,799 --> 00:10:36,120
Scott Tolinski: Yeah. Which is that one of the nice, like, I think that's a low key underrated aspect about a lot of things in development, right, people want to jump to this next great thing, right. But now, like, a lot of times, the thing that's around an established has such an amazing community behind it, that's already built the stuff that you need. So when you go needing something, you're not gonna have to really scramble through either incomplete or stuff that's still being built or any of that stuff. I mean, it's a low key aspect of really established frameworks.

16
00:10:37,230 --> 00:11:10,919
Wes Bos: And of course, you can use any other language you want to to create an API, you could use Laravel, if you're in PHP, you can, I don't know what the Ruby on Rails comes with this. It Ruby on Rails sort of like made this popular. Yeah. Where it came with everything built in to create an API. And I think that really rocketed forward these sort of JavaScript based websites, which is pretty cool. So and any server out there that can accept a request, and then return a response at the end of the day can be used to make an API. So next, let's

17
00:11:10,919 --> 00:12:46,409
Scott Tolinski: talk about documenting the endpoints because this is actually a huge thing, right? If you have an API and you expect anyone to use it, let alone yourself or anyone on your team. Or if this is a public API, then this is even more important. You need to document the endpoints, you don't does the best job of this is, in my opinion, I think stripe does the best job of this. They have their their side by side documentation, where they show you what the end point is, they show you exactly what you're going to get back. And then they have on the the left side of it. I believe it's just the I don't have it pulled up right now. Maybe I should. But it tells you exactly what the different parameters, what the different headers needed, what everything is needed to make this query work really well. And it is, yeah, okay. So basically, on the right side, here's what you'll return. Here's the endpoint that you'll hit. Here's the different CRUD operations you can do on those endpoints. And then here are the different attributes or parameters, you can pass into that endpoint to augment what you will do get back. So this is such a huge aspect of any particular API, that you'll want to really pay close attention to how you're doing this. And in my mind, the best option here is to just copy the people who do it well, and don't try to make up something yourself. Because there's so many bad ones. I don't want to call anybody out. But I've used my fair share of awful API documentation. And most of the time, I'm just wasting our stripe. Yeah. I'm not gonna call anybody out. But West is happy.

18
00:12:49,919 --> 00:13:30,360
Wes Bos: Yeah, so it's awful. Just because it doesn't describe like what things do. And I know that they're working hard at that. And they have a lot of balls in the air, and they have different products in different countries. And it's a hard problem. I certainly wouldn't want to solve that problem myself. I just like to complain about it. But so what else do you need when you document it, like Scott says, document what parameters are required and that those parameters can be anything. So if you are requesting donuts, maybe you want to filter by cake, or yeast, if you are want to, if you want to sort them by the the time that the donut was created, then you could you could do that

19
00:13:31,020 --> 00:13:33,840
Scott Tolinski: you got done. Today, you got doughnuts on the

20
00:13:35,039 --> 00:15:04,830
Wes Bos: doughnut API. And that would not actually be a pretty fun little app to do. Maybe I'll tuck that away in my Yeah, tuck that away in my list of things to build. Pretty much the parameters are a Scott also has here like if they're required or not, they need to be documented. Because often you will say like, give me a list of doughnuts. And you can hit that API with no parameters. And it will give you back a list of doughnuts. But if you were to I don't know, what's another good example, if you were to get a list of food, maybe it says like, you can't just request all the food, you need to tell me the type of food first. So you'd have to pass a type puram along with it to do it. Also document what headers are required. So kind of a tricky thing about params and headers is that sometimes you need to send data along to an API via headers, and other times you need to send it along in like the body of the request, or as a get puram. We'll talk about that a little bit more. So just make that super clear. I know I've spent lots of time on API's being frustrated, because they just assume that you know, to send it as a header or whatnot, document what you get back when you hit the endpoint. So just a simple example of what data comes back is so helpful, because often, you aren't looking at the API URLs. You're just basically like I need this piece of data and looking at What you get back, and then you can sort of trace it backwards is super important.

21
00:15:05,190 --> 00:16:11,429
Scott Tolinski: Another cool thing is if you have an API that exists in Well, I mean, whether or not you have any, like a software API that exists in different languages, but if you have, you know, code that you're expecting your users to just be able to figure your thing out. Good practice is to have like examples of hitting your API in different language. Yes. And one of the things I really love is when they have a drop down, or something like that, on the page right there, there's just like a little drop down, maybe it's in the header, maybe it's somewhere on the documentation page, but you can just say, oh, convert these examples to Ruby, and, you know, convert these examples to JavaScript, whatever, and it will just change it all. And that gives your users the people consuming this API, the ability to just copy and paste if that is a thing. That is like if you're expecting people for different languages to be using this. If it's your own team's private API and stuff. This isn't like a hard requirement. But for really good public API, specifically ones, like the ones that we consume every day with Braintree, PayPal, whatever. I think this is a great practice. And something I'm always happy to see inside of API Doc's,

22
00:16:11,490 --> 00:17:44,090
Wes Bos: I love that. What drives me nuts is when they don't provide anything at all, or when they just provide like a curl example. Curl is the command line, sort of equivalent of fetch, where you can just like make requests on the command line. And now that I understand what curl is, it makes sense to me. And I'm able to parse that into whatever language it is I'm working in. But as a beginner, I remember being so frustrated being like, what, why do I need to curl this, like, I'm using JavaScript here, and like, you should know that like, okay, most like 98% of your users are either using PHP, JavaScript, or Ruby. So just give a couple examples of how to use each one in each of the languages. And that goes a long way. Other things you need to put in your documentation is what's called the HTTP verb. So when you make a request, and in any language, you can send that request as any number of different verbs. So you can make a get request or a POST request, those are probably the two most popular that you're used to just when dealing with, with forms, in general. But there's also put requests which are generally used, generally the the thing I'm saying generally a lot here, but yet is used to pull data post is used to create data put is used to update data, and delete is used to, obviously delete data. And then there's there's some other ones, there's like options, which I've never used in my life, I pretty much just stick to GET and POST, even when, even when I'm updating or deleting.

23
00:17:44,300 --> 00:17:59,550
Scott Tolinski: Yeah, is it because getting posts were the you know, the Oh, geez. And then the other ones are new. So for a long time, a lot of API's didn't have the ability to do anything other than a gator post. So you just had to do get post, and then act accordingly.

24
00:17:59,810 --> 00:18:35,550
Wes Bos: Yeah, the other thing about rest API's is that there there is sort of a couple like standards out there of people who have said like, this is how you create a RESTful API. But I, in my experience, nobody really follows that they sort of just kind of cowboy however they want. And the thing with graph qL is that it is a living standard, it is a spec, and you must conform to that spec. So things are a lot, a lot less sort of wild west and trying to figure out how things were rigid with graph qL, which is great. Yeah, it's much more rigid and graph qL world which can be frustrating. But seriously, it will help you in the long run.

25
00:18:35,600 --> 00:18:53,160
Scott Tolinski: Yeah, definitely. And if you want to have a standardized API, and a really nice way of building one, here comes one of our sponsors, and that is sanity@sanity.io. It's a back end for your site's front end. And it is really super cool.

26
00:18:53,430 --> 00:20:52,710
Wes Bos: So speaking of API's, if you do want just to be given an API based on sort of the data types that you have, you can use Sanity. Sanity is a structured content CMS, where you go into the back end, you go into the the Sanity dashboard, and or they call it the Sanity Studio. And you can create your content types, you can create that kind of food for the type of doughnuts, you can create people that have cooked those donuts, you can relate those things together. And then that at the end of the day will just kick out an API will that allow you to do all of the CRUD operations. So they will give you an API. I'm just reading through an email from them here. They've got all kinds of new stuff, which seems pretty cool. They've got a History API, meaning that if you update data, or you unpublish something, or you change some data, you're able to go back in time and see what changed and when that change, which is pretty nifty. You can both see that in the the Sanity Studio, but you can also get that data via the API. So like even if you're doing like, like a Twitter clone, you know how like Twitter doesn't allow you to update tweets. You could with this use the ability to update a tweet. And then you could show the previous iterations of that tweet with this new API, which I think is pretty cool. Super cool. Yeah. What else the they've got real time content preview coming for grid some. So they were sort of the first one on the scene here with real time updates in Gatsby. And now they're, they're moving that over to grid view. Yeah, all kinds of nifty stuff coming up, I highly recommend you check it out. sanity.io forward slash syntax, that's going to double your free usage tier. And also go to sanity.io, forward slash create. And that's going to show you just a bunch of examples with Gatsby and next and nuxt and bunch of other stuff there. Check it out. sanity.io forward slash create. Thanks so much, Cindy, for sponsoring.

27
00:20:52,850 --> 00:20:53,430
Scott Tolinski: Nice,

28
00:20:53,430 --> 00:20:54,390
Unknown: cool, yeah, I

29
00:20:54,390 --> 00:22:17,160
Scott Tolinski: think this is, I don't know, I don't want to say this is a golden era of anything. But like, this is just such an amazing time to be building API's in general, we have so many great options. And if you want to get into it and write your own rest and graph qL API, you can and if you want to use a service like Sanity to make your life that much easier, you you can do it and it's gonna be awesome. So I mean, what a What a cool time to be building fun stuff like this. So next part, we're going to talk about naming things do you think is one of the hardest parts about software development, as we all know, can be tough for developers to name things. But I always like when API's are named, obviously, I don't know how you view naming endpoints and things like that. But personally, for me, since I'm primarily working in graph qL, I have a fair amount of resolvers that rather than just having like a tutorials, or tutorial, I have a whole bunch of different resolvers to make that a little bit more micro to what I need. But going along with that, I do like to make it entirely obvious, aka if I need to hit tutorials, I name it tutorials. Now, obviously, this is different from a REST endpoint. But the concept remains the same. It's pretty much here's the object, here's the object pluralized. And then if I have some more specialty ones, it's narrowed down by how specialized those are. What are your thoughts on naming things like this?

30
00:22:17,490 --> 00:23:57,360
Wes Bos: Yeah, I generally like to use like a noun. So let's use doughnuts, again, Ford slash doughnuts. So you use the pluralization of the noun, never use like, never use like a Ford slash create donut, because the verb is done in the HTTP verb. So you could have an endpoint, that's Ford slash doughnuts. And if you get that endpoint, it will give you a list of of doughnuts. But if you post to that input, or that endpoint, then it will create a donut. So the same URL depending on what verb you have, can do different things. Then also the the beauty of that is that you could do forward slash donuts, forward slash the donut ID. So if you have like donut seven, and then you can hit that endpoint, and you can either get the data about that specific donut or update that specific donut or delete that donut. So that's kind of what I stick to pretty simple. In how it works. There is this great website called RESTful API. And they have a whole page just on like best practices for naming your endpoints. Because it's easy at first. But when you get into it, when things get complicated, your endpoint URLs can get really gnarly. And also you can, you can like start creating multiple endpoints because you're like, I have donuts endpoint. But now I have doughnuts and pies. Yeah. And now I have like doughnuts and pies with authors endpoint. And that's the whole reason why graph qL was created. Because before you know it, your your needs change. And then you've got all of these crazy endpoints just running amok. And graph qL sort of takes away from that.

31
00:23:57,420 --> 00:26:59,820
Scott Tolinski: Yeah. And that's it. That is a very, I don't know, it's a very common thing. And API's in general, for naming, it will get tough. And I personally, have spent a lot of time trying to optimize and change these and whatever. But it's always good to have a idea of what the API is going to look like ahead of time so that you can really put some forethought into planning these out. Because if this is a public facing API, and the API version is like, version that people are using, it's gonna be really hard to change those in the future, because you don't want to break people stuff. And I mean, obviously, you conversion the API, but Oh, yeah, yeah. So that's a whole nother idea is that versioning of an API, which I can talk about right after this, but it's over time, this API will most likely change and evolve. But if you are constantly changing the endpoint names, you're going to kind of make people angry because they're gonna have to update their code. It's almost like changing the version of a library. Now, they could always stay on the older API, but chances are, it's As the API grows and changes, they're going to want to take and get access to the new things in the API. So that's the whole thing, too, about versioning and API jermy. To get into that now already, why did you have Martin? Yeah, yeah. So a lot of times companies have different versions of an API, because the initial version of the API that you wrote is most likely not going to be the same one forever and ever. And many of these API's, they give you the ability to use an older version of the API. That way, when you hit the API, it's not just going to magically change on you. So by versioning, it, it's sort of locking in that functionality to a given point in time. One of the companies that does this really well obviously, is stripe within their API documentation, even based on what your account is set at you, you set the API version for your account. And then all of the documentation that it shows you is for that version of the API, therefore, you're never looking at older, outdated Doc's and you don't have to worry about it yourself. Sometimes you had to an API, and you might be using version two. And you might not realize that and you're looking at the doctor version three wondering why this thing isn't working. So firstly, an API is an extremely important thing to make sure that you are accessing the correct version of whatever you're trying to hit. But it also gives library authors the ability to change update the API. But as we mentioned, you're not going to want to go ahead and changing things like crazy. Otherwise, you'll make people upset stripe also does a really good job of showing what's deprecated inside of the API. So like if you're on version, I'm just making this up. But let's say you're on version, like five or something, if there is a version five, and one of the API methods is going to be going away in the next release, you can mark it as like deprecated, do not use and show like what you should be using instead, within that version of the API. That way, when they get the next version, they're not going to be stuck with a bunch of code, they have to change because they already know they shouldn't be using this thing.

32
00:27:00,180 --> 00:28:36,660
Wes Bos: Another thing I love about stripe is that the version of the API can be tied to the API key. It can be tied to the URL, and then it can also be overwritten per request via header. And that's great if you need to slowly upgrade your entire API. Because there's nothing scarier than moving your entire income at once cutting fresh over. So what you can do is you can stay on version two of the API and you can set a header on each request saying this is version three of the API. And then you can update those slowly as you go. And as you have time to do that word. Next up, we have securing your API. So it's likely that parts or all of your API needs to be only accessible to certain people with the right credentials or the right authentication. So there's a couple of different ways that you can secure an API. First is this probably the simplest is only accept requests from logged in users. So that could be a cookie session, that could be a JW. T. You could also use OAuth, which is a little bit more complicated, although a lot of popular big popular API's use that. Other ways you can give people API keys. So you can just generate a random ID and give those out to people. And then you can track the number of requests that go against that API key and different API keys can have different authentication. You can use cores, which we have an entire episode on what cores is cross origin resource sharing meaning, should this API be accessible in the browser? Or is this more of just only a server side thing?

33
00:28:36,900 --> 00:29:44,430
Scott Tolinski: Yeah. And there's also, one of the things you're going to keep in mind is the access level of your users. I mean, this is a huge one, if you're have any sort of content that is not only, you know, sensitive, right? Like, you don't want to be able to hit an API and get access to every single users all of their information, right? But maybe some administrators need access to those kind of things. So you can check the access level on the server to say, Hey, does this user have the credentials needed? If they have the credentials needed? Here? they can, they can access this information. Otherwise, you can throw an error that says authorization error or something like that. That's typically what I do. You're going to want to be doing this for not only your GET request to get the data, but all of your modification requests. For instance, what like, think about a tweet, like you said, We let's say we wanted to edit a tweet, which you can't do. But let's say you wanted to edit a tweet. You don't want to be able to edit anyone's tweet, you want to be able to edit only the tweet that you wrote yourself. So you would check to make sure that the ID of the tweeter is the same as the ID of the tweet before you allow them to edit it.

34
00:29:44,610 --> 00:30:22,260
Wes Bos: Yeah, in my courses, actually, we create a lot of little helper functions for that where like you say, like, has the ability to edit this thing. And you can you can either check if they own it, or if they are an administrator. We have I think we have it Entire podcast talking about like roles and authentication roles and levels. Because that's that's a whole different way to how to approach it like you can do different levels. But then you can also do different things like can edit can delete, it gets pretty complicated. But there's I like that episode, I thought it was pretty nifty. I changed how I did my own roles in my own applications, after I had asked on Twitter about that is pretty good.

35
00:30:22,710 --> 00:30:27,480
Scott Tolinski: Yeah, there's a lot there. That's a whole whole thing in itself is designing that aspect.

36
00:30:27,720 --> 00:30:34,440
Wes Bos: One other thing that could happen with an API is that you have errors in your API, and I don't know how would you track those Scott?

37
00:30:35,280 --> 00:33:54,860
Scott Tolinski: Ooh, I don't know. You know, me personally, I might track them with a piece of paper and a pencil. When they come in No, I I'm gonna check them with century myself, because I'm a big fan of one of our sponsors today, which is century@century.io. No century is constantly saving my butt, because it's allowing me to see the errors that are coming into my application allows me to see how many users are hitting those. And it allows me to do things like assigning them to an individual, it also gives me a chance to really understand some things whether they are bugs inside of a library or or even a browser, right, for instance, I've been getting, I'm just getting this one error in my, my front end. And it's telling me that it's losing the connection to the WebSocket. The error is really interesting. And for I was really confused about why this error was popping up. I wasn't seeing it myself, until I went to the events section, the Events tab. The Events tab shows you every single time this happened. And it's in a giant table that shows you when they happened, the browser version, the browser name and the operating system version, the operating system name. And this was a bug that I couldn't for the life of me understand until the events section showed me that every single time this event happened, it happened with Firefox. So no matter how many users or what users Firefox was always to blame. And sure enough, this is actually a bug within Firefox. So it's not even something I have to worry about. So I can just go ahead and click select the error and click ignore. And I don't have to think about it because it's not affecting the users experience. But it's coming up nonetheless. And it's gonna fix itself on its own. So essentially allowed me to figure that out instead of allow it instead of having me really just ruminate on this bug that was not really a bug at all. So thank you so much century for constantly saving me a ton of time. And you'll want to head on over to sentry@sentry.io, use the coupon code, tasty treat all lowercase all one word, and you will get two months for free. Something I highly recommend you do if you have any application that users are using. So thank you so much for century for sponsoring. Next, we want to get into protecting your API, this is not necessarily the same thing as a security. But it's along the same lines of that you'll want to be able to protect your servers and your computers that are serving up this data, all sorts of malicious intentionally or unintentional activities. Sometimes people are hitting your API, it's, you know, public API, they're hitting it, and they're not intending to be malicious. But they're still maybe wrote some bad code that's causing the whole thing to hit it 1000 times. So one of the things you can do is to rate limit, which kind of is a fun way of just saying, hey, if somebody's doing something too many times in enough, like an A, like, let's say I click this button, or hit this API 100 times in less than a second, right? They just hit it that many times, it just hit rapid firing. The API can say, Whoa, whoa, hey, can you not? Can you not do that? How about you wait some time before you hit it again, otherwise, I'm not going to serve up this date anymore. This prevents people from hitting it thousands and thousands of times crashing your server overloading things preventing fast queries for other users, or anything like that. This is definitely an important thing to have on your API. If people are going to be using this.

38
00:33:55,020 --> 00:35:44,880
Wes Bos: Yeah, you can you can rate limit an API by the users API key. So something like Google Maps gives you an API key. And you can only make 30,000 requests per API key, then you can also rate limit it by a person's IP address. So if it's a client side API, you could say only each person can only hit this API 100 times per day, or or once, per once per second, or once per 10 seconds or something like that. And what that does is it puts the rate limiting on the user themselves, not on the API key. other stuff that I do is a whitelist and blacklist. So if somebody is pinging it too frequently, or if it's a known sort of bad actor, or if it's coming from a known set of IP addresses that are bad. CloudFlare helps a lot with this as well. If you put your API behind CloudFlare they just know when things are bots and spammers. So they'll they'll sort of try to do that. It's really important that you put these things in place before You get an API in email for in the morning where your servers being pummeled or it's really hard to lock down an API because you're essentially giving people programmatic access, pulling and creating data. That's That's why Twitter has such a, an Instagram has such a hard time with opening up their API. If you look at API's over the years, Twitter used to be super open, it was amazing, you could create anything, and Instagram had a really good API and so to Facebook, and now it's so locked down. And that's half because they want you to like use their own apps and stay on the platform and suck their ads in. But it's also just because if you give spammers like the tools to to push content to it, they're gonna abuse it.

39
00:35:44,940 --> 00:35:49,350
Scott Tolinski: Yeah, making bots and disrupting elections and those kind of things.

40
00:35:51,210 --> 00:37:14,550
Wes Bos: Yes. So the last thing we need to talk about is Oh, sorry, the second last thing we need to talk about here is, is actually making it happen. So and I like to call this a resolver, or controller. And this is where the actual work happens. So when somebody hits your API, they're either they're crediting, they're creating a doughnut or updating a donut. They are see are removing create, update, delete, they're either doing one of those operations, yeah, you're doing it right. And when someone hits it, you need to do the work. And most likely, what that is, is it's looking up stuff in the database, it's checking for authentication, it's saving data to a database and waiting for that to come back. And that's what we call a resolver. So update the data, get the data, fetch the data from the database, and then send back to the user, both the data that they need, so often it will be an updated record. This is the updated donut, but also sending back the correct HTTP code. So if there was an error, you send a 404. If it's an authorized use, I think you sent a 503. I don't know them off the top of my head. And then also, I like to log what happened as well. So if you ever need to go back and say, like, who actually changed this data? You can, you can save some logs as to what happened when?

41
00:37:15,630 --> 00:37:53,210
Scott Tolinski: Yeah, totally. Yeah, logging is one of those things that is, is pretty important when you're running an API, because if you are having things mysteriously happened, again, there are a lot of services, I don't know, if you use anything specifically for locking, I've used a couple of them different ones before, then that I wouldn't necessarily jump to recommend. But if there's any that people are using, I'd be interested in knowing what people are using to, to log in to be able to store logs, other than writing a custom log or a custom log list, I guess that maybe might be the best idea. But it's just a little bit of work. In that I think you you pretty much covered everything.

42
00:37:53,690 --> 00:38:05,940
Wes Bos: Awesome. Well, we'll wrap it up here with some tools. Do you have any specific tools that you use when when creating an API testing an API, anything like that, documenting now, to be honest, I

43
00:38:05,940 --> 00:38:27,650
Scott Tolinski: don't I especially because I've been working with graph qL so much, pretty much all of my tools resolve around Apollo. And it's just like the Apollo stuff. You know, I use Apollo engine to make sure my queries are fast, and all those good things. Now, I don't use anything specifically to test any of this stuff. My platform is all pretty. I don't know, I don't want to say basic, but it's pretty contained.

44
00:38:27,860 --> 00:39:13,650
Wes Bos: Yeah, me too. Over the years, I've used postman quite a bit, postman is a Chrome extension or app that will allow you to debug requests. If you're having a hard time figuring out what's going wrong. Sometimes writing like a fetch request in JavaScript is not good enough. And you need more insights into what's going on. And you can save requests. a postman is great for that. A lot of people have told me to use swagger, which seems to auto document, your API. So if you write your API in a specific way, it will automatically create documentation, which is great, because writing doc sucks. Yeah, those are pretty much the the two I don't I don't go super heavy into this type of thing, just because it's mostly just me. And if I need to figure out what happens, I can just look at the code myself. So

45
00:39:13,730 --> 00:39:52,110
Scott Tolinski: yeah, that is a thing because we're both writing API's that other people aren't really consuming, you know, I my API is is consumed by me and the developers on level up tutorials. And that's it. And because of that, it's, it makes it pretty easy to to not have to worry about some of these things. But at the same time, you can take it for granted. And as your team grows, and certainly as my team will grow these things have to be continued to be documented and improved. So now we're going to get into the part of the show called sick pics, where we pick things that we find to be totally sick, and they're usually it could be anything. I have a podcast, they do have something for your sick pick with.

46
00:39:52,530 --> 00:39:59,630
Wes Bos: I do it's so you've been recommending solar lights like crazy over the past. I don't know six or so.

47
00:40:00,000 --> 00:40:01,710
Scott Tolinski: Yeah, here

48
00:40:01,940 --> 00:41:12,060
Wes Bos: we are we at our cottage we have these like steps that are like it's weird. It's like 10 feet of deck and one little step 10 feet of deck, one little step and 10. It's very gradual. And what happens is people don't see it and they, they, they do that thing where you step, yours walking and you didn't realize there's a step. So you go, boom, right, and I don't want someone to bail on it, especially when it's dark out people don't see them. So we got these little solar lights that sort of clip on to the side of a deck or a dock or something like that. And they're awesome. They're super bright. They they run for I'm not sure I haven't slept a lot. I've been sleeping when they're mostly on but they've been running for. Apparently they run for all night, eight to 12 hours, which is awesome. They're pretty easy to install. They're waterproof, which I'm going to put we just built a floating dock. I tried to put them on there. Oh, that don't run it run into this thing. Yeah, and it 50 bucks Canadian. I'm sure it's like 30 American for a packet eight. Big fan of these. I think it just like looks slick. It looks like that. I was like this looks like an expensive restaurant. I was telling my wife.

49
00:41:12,090 --> 00:41:16,560
Scott Tolinski: Yeah, yeah, I saw that photo. I was like, Oh, yeah, this looks great. Yeah,

50
00:41:16,590 --> 00:41:41,760
Wes Bos: yeah, it's, it's nice. It's what are they called? They're called upgraded solar stair lights environmental friendly. They don't even have a name there. They're just like some random generic design one. Yeah, but I'll put a link to them in the show notes if you want to check them out. Highly recommended. It's just a nice way to class up your backyard or, or add lighting to a spot where you don't necessarily have a floodlight or or power to run to it. So big fan,

51
00:41:41,760 --> 00:42:11,960
Scott Tolinski: I want a solar light everything now that I've done this, dude, I'm on the solar light everything and we have these like I mentioned in one of the episodes, but we have these you know, hanging down lights that are just awesome. Yeah, be solar powered. I just like clipped it to my fence. You don't have to you can put them anywhere because you don't have to plug them in. And then I have like these little fairy lights in the in our peach tree. And you can set them to like twinkle so you go outside and the peach trees twinkling I'm like, Oh, yeah, this is great. Kind of back on peach tree.

52
00:42:12,150 --> 00:42:15,330
Wes Bos: I want to come over hang out with you. That sounds fun. I know. Right?

53
00:42:15,360 --> 00:44:17,190
Scott Tolinski: Yeah, just just wait till it's like peach season and like our backyard smells like fermented peach wine because all of the peaches have fallen. And it's it's whenever rotting. Yep, I love it. Cool. So that Yeah, dude, these things are amazing. I got to check some of these ones out that you got they're really nice looking. I'm gonna say pick a podcast because I like podcasts. And this is, you know, I did a couple of podcasts recently that weren't in the realm of swindling people or hacking people. So I'm gonna I'm gonna go ahead and change that up. I'm going to go back to you know my niche of those kinds of podcasts. But on the latest episode of swindled which was awesome, by the way, they recommended a podcast called hoax h. x. And this thing has been awesome. I listened to I've gone back for a few of the episodes. And let's see, I think there was one called Operation mincemeat, which is about an operation in World War Two, this deception operation in world war two that I did not know about. I don't know how I didn't know about this, but it was amazing. And it totally blew my mind that this thing had happened. There was an episode about Andrew WK, which was ridiculous. Every single episode I've put on so far has been very different and very interesting. I mean, it went from World War Two to Andrew WK to a high school student, manipulating his his classmates to like Russians who are selling property they didn't own every single story has been absolutely fascinating. And it's it's really well done Hi. So I've been I'm really enjoying it if you like any of those other pics I had like swindle dirt dark net diaries. So like hoax. There's a weird thing about hoax, though they do ads in hoax, but like, I don't know who's in charge of doing the ads, but they just like, drop them in in the middle of the audio. So somebody will just be talking. And then all of a sudden this ad will just come in. And then sometimes they play the ad twice. So I don't know who's editing this podcast. It's not good in that aspect. But the content is awesome in the production none. Everything's great, except for the advertisements how they choose to do that. I

54
00:44:17,190 --> 00:44:20,970
Wes Bos: was like, you need to go over there and tell them how to transition and add you

55
00:44:21,930 --> 00:44:25,170
Scott Tolinski: been? I think I'm gonna start a workshop. Yep. Here's how to do it.

56
00:44:26,940 --> 00:44:40,080
Wes Bos: Awesome. So for shameless plugs. Today, I'm gonna plug all of my courses at West boss comm forward slash courses, use the coupon code syntax to get 10 bucks off, and the free ones you can get for free. What do you got today?

57
00:44:40,140 --> 00:45:29,250
Scott Tolinski: I'm going to be plugging the course that's coming out on when you're listening to this. It'll be coming out on Saturday. And it's going to be on Gatsby. And it's going to be not only just on Gatsby, but it's gonna be on Gatsby and Shopify. I know this sounds familiar, because last month of course was also on Gatsby e commerce but this one dives deep. We go deep into building a site with Gatsby and Shopify, it is going to be really super interesting. We're going to be building a full on e commerce store with a custom shopping cart, none of this iframe stuff like we did in the last series. So if you're looking to take what you learned from the first series and step it up a notch or you just want to really get into building headless ecommerce sites, check it out. We're going to be building that over on level up tutorials. COMM sign up, become a pro for the entire year and save 25%

58
00:45:29,400 --> 00:45:37,530
Wes Bos: Beautiful. All right, I think that's it for today. Thanks so much for tuning in and we will catch you in the next one booze pace.

59
00:45:39,360 --> 00:45:49,140
Scott Tolinski: Head on over to syntax.fm for a full archive of all of our shows. And don't forget to subscribe in your podcast player or drop a review if you like this show.

