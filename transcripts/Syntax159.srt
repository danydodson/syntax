1
00:00:00,359 --> 00:00:24,480
Announcer: Monday, Monday, Monday, open wide dev fans yet ready to stuff your face with JavaScript CSS node module BBQ Tip Get workflow breakdancing, soft skill web development hasty as crazy as tasty as web development treats coming in hot here is Sarah CUDA, Bob, and Scott, Todd. Totally in ski.

2
00:00:25,890 --> 00:00:52,860
Scott Tolinski: Or Welcome to syntax in this Monday tasty treat, we're going to be talking all about security and front end security specifically. So we're going to be keeping this largely and and very largely related to front end stuff. But more or less, what are the things you sort of need to know a little bit about security on your website. So my name is Scott Tolinksi. I am a developer from Denver, Colorado and with me, as always is West boss,

3
00:00:52,920 --> 00:00:54,000
Wes Bos: sup everybody,

4
00:00:54,180 --> 00:01:45,120
Scott Tolinski: sup sub West? This episode is sponsored by a longtime sponsor of syntax, and that is century century is the really excellent system and service for tracking, logging, storing, keeping track of just all of your bugs. And this is one of these tools that if you run any sort of site that users are facing, you're going to want to make sure that you have a system in place to be able to track log and know exactly what's happening on your site at any time, we highly recommend you dive in and check out century@century.io This is a service that both West and I've used for a long time even before we've recorded this podcast. So we're big fans over here at syntax. So again, check out sentry@sentry.io use the coupon code at tasty treat all lowercase all one word, and you will get what will you get West? You'll get two months, two months

5
00:01:45,420 --> 00:01:46,230
Wes Bos: for free.

6
00:01:46,260 --> 00:02:11,750
Scott Tolinski: tu tu tu tu tu tu tu mods for free? Yes, I'm ready to go. I've had one heck of a morning this morning. We now have two kids. And I have a bunch of new responsibilities in the morning and apparently still getting used to those responsibilities. I'm lagging hardcore. I'm chucking back some coffees and some cold brews, some brewskis some cold brewskis. And I'm feeling ready to go. How about us? Yeah, yeah,

7
00:02:11,760 --> 00:04:11,310
Wes Bos: I'm ready to ready to rock and roll. So we're gonna be covering a couple sort of things about front end security, lots of your sort of security stuff needs to happen server side. But there are like a handful of things that you need to know as a front end developer, so that you don't sort of shoot yourself in the foot. By accidentally doing something, I think that's something I hear from a lot of people, they say then yeah, that's called a foot gun where like, you're like, I don't actually know like, what I'm, I might be doing bad. And there's probably just a handful little things that you need to be aware of. So you don't actually set yourself up for your entire website being hacked or for your users data being taken away rogue. So first one we have here is it has to do with sort of sending data. And that is whenever you are sending, I would go as far as to say whenever you are sending any type of data that must be over a secure a secure origin, meaning that the server that you're sending the data to, as well as, like I don't want to get too, too in the weeds here. But the website you're serving it up on should have an SSL certificate. So what this will do is when you have an SSL certificate, obviously, you get that little green lock in the URL bar that you have. But sort of the what happens there is when you have a website that talks to a server, the data that is being sent from your your users website, over the Wi Fi through the internet, through the government, surveillance, and finally to your server. It's encrypted all the way along, meaning that if anyone were to intercept that data, if anyone were to sniff that data, they still do know about like, like what website it's going to and the size of it and and things like that. That's why ISP can still throttle things like Netflix when they're still using SSL, but they're not able to sort of dive into that data and inspect it as as it were raw text where with HTTP, you totally can you can intercept data requests that are going anywhere. And you can see the entire payload in plain text.

8
00:04:11,490 --> 00:05:05,390
Scott Tolinski: Yeah, so I mean, that's really it is that the seeing the the payload in plain text, I mean, imagine you're on like an airport Wi Fi, and you're entering your credit card information and sending that somewhere down the line. And everybody who's on maybe the same network and is doing some sniffing, sniffing around different for that packet might be looking at that information because it's unencrypted. So that's really where the SSL comes into play here is that it's not only just encrypted but encrypted to a key that's connected to the organization's details, right. So when you apply for an SSL, it's attached to basically you as an Hey, this is level up tutorials.com. This is level up tutorials, sending the message and the encryption is connected directly to that organization, rather than Just some, you know, just some generic key or something it yeah connected

9
00:05:05,790 --> 00:06:06,720
Wes Bos: and the server to like the you have to, in order to get an SSL certificate working, you have to sign it, which means that your your cert, you have to prove that you own the server. By the way, there's a number of different ways that you can like sort of do that. But the most obvious one is just you just put an HTML file on your server. And then the people who are issuing the certificate check if that's there, and they go, Oh, thanks for putting that very specific HTML file here, you must actually own the server, and therefore we're going to issue you this certificate. One sort of other thing to note is that a lot of new API's that are somewhat sensitive things like webcam, geolocation, those will only work on a secure origin, meaning that you either have to be a local host, or you have to be on a HTTPS website. And I think that's good, because you shouldn't be able to get people's microphone pictures of people data about where somebody is without actually being in a secure environment, because you could potentially send that data over the wire and it shouldn't be able to be sniffed.

10
00:06:06,900 --> 00:08:09,990
Scott Tolinski: Yeah, we want to stop those sniffers. Just put a plug right up those sniffers. All right, next one here is going to be talking about setting inner HTML. And this is actually, you know, a fun fun question is that people who use react will often see this when they want to insert some HTML, like maybe they have some HTML saved in the database, or coming in from an API, and they want to use it. And they have to go ahead and use this prop called dangerously set inner HTML, which sounds super scary. And believe it or not, it was actually named to sound scary, because this is going to sort of go along the lines with some other stuff we're going to be talking about later on in this episode, but largely that you have to know sort of what is going on places what the data actually is. And it needs to be always what you expect it to be. Because simply just inserting HTML into HTML isn't necessarily a security risk as long as that data has been sanitized? And is that definitely what you're expecting it to be aka, just straight up HTML, maybe, yeah. And so that gets into the point of sanitizing, which is just sort of a word that you may have seen around before. And I wanted to quickly touch on WTF is sanitizing before we get into some of these other things about this inner HTML, because sanitizing comes up a whole bunch throughout any security things because sanitizing, if you have heard the term before, and maybe don't know what it means. And maybe you can just guess, because it really feels and has a lot to do with what the real world definition means for sanitizing aka you're cleaning it, you're cleaning the data, you're removing unexpected data from that string, just like you would sanitize your counter, you're removing germs that should not be on the kitchen counter. They shouldn't be there, get rid of them sanitize. And that's exactly what sanitizing is. So this can be very important for anything. When you're inserting code into the into your site. It can prevent all sorts of stuff.

11
00:08:10,020 --> 00:08:25,590
Wes Bos: Yeah, maybe we should talk about like, how, why is this unsafe? So like if you have like a user's input for their name, or their bio, the users name could be Wes Bos open script tag, hack your bank account closed script tag?

12
00:08:26,100 --> 00:08:29,270
Scott Tolinski: Yeah, mine some cryptocurrency? Oh, yeah,

13
00:08:29,340 --> 00:10:14,010
Wes Bos: yeah. So if the user puts any sort of HTML in their inputs, and then you dump that data into the DOM as HTML, doing it as text is not an issue, because you can set it like dot inner text or setting text into anything is totally fine, because it's not going to be parsed as HTML. But whenever you're you're taking, like creating some HTML, and you have data that's from a user, you cannot trust that the user did not maliciously put in a script tag, or is probably the most, the easiest one is go ahead and make an image tag and put a source on there, and then put an onload attribute. And the onload attribute will actually be fired by the browser and run whatever JavaScript is in the onload quotes once the image has actually loaded. So that's the very easy way to see how it might go awry. And I like to use like I personally and a lot of my courses, I always use ESX template strings to scaffold out HTML because it's way easier than doing document dot create element div document dot, create element, paragraph, paragraph, enter a URL that txt equals Hello, and then you take the paragraph and put it in. It's really knowing that that's why JSX is has been made, because it's really simple. And you are almost very set. You're always very safe in react world because they don't let you do those things. But if you're just using vanilla react, or sorry, if you're just using vanilla JavaScript, you could accidentally set some inner HTML and then you'd be pushed. So it's not that you shouldn't use that. It's just that you should run it through. I use something called Dom purify. And that will just strip out anything that is potentially malicious. And you can also allow it to let things through. So maybe you do want to allow people to have code blocks or image tags without the onload attribute, things like that. Yeah,

14
00:10:14,219 --> 00:12:01,530
Scott Tolinski: yeah, definitely. Cool. So we did talk about sanitizing Do you want to get into the next one, which follows along right along with this, which is about sort of the I think it goes hand in hand with this is just not to trust anything coming in from the client. I mean, that that is, in my opinion, that's just a good rule to live by 24 seven, with any front side security is never trust things that are from the client, because the client can be manipulated by the user. So in any particular use case, you're always going to want to make sure that you're checking the data, you're sanitizing the data, you are type checking the data as well. And this is one of those things you get out of the box for free with graph QL. Because you're always type checking the data has to be very specific types. And neither information that's getting passed along the server has to be the explicitly set types that you have. So basically, we never want to trust information that's coming from the client, whether that's from an HTML form, e commerce or anything like that. And that said, you know, people, they've added client side form validation to html5, whatever, however, many years ago at this point, when when they did that, it was a big deal. But a lot of the times people maybe Miss misconstrue that with, okay, well, this html5 is validating my data. So therefore, I don't have to do anything else with it. And that's not really the case. Because even if the forms, the form validation for html5 is really just a UI kind of thing. It's really just to let your users know, rather than to be any sort of security measure, it's just an extra little layer there. So you always need to check types, check the data, make sure you check it when it enters your server, before you're inserting into your database before you're doing anything with it that could potentially just run some code that you might not know exactly what it is.

15
00:12:01,709 --> 00:13:27,450
Wes Bos: Yeah, I saw this when I was building my advanced react course, every single example that I looked at, even with graph qL, they would take the price, and they would calculate the price on the client side, and then just send that to the server. And that made me really frustrated. Because obviously, yeah, it's a simple example. You're just doing a quick little tutorial. And the whole like having to recalculate the carts. Total cost. Yeah, on the client side, and the server side is annoying, but you absolutely have to do it. And otherwise people will just change the cart. But people do this me all the time. It changed the product to one cent. And then it says like, the success charged your card for one cent. And they think they hacked me and then they get their credit card bill. And it's obviously I'm checking for the I'm recalculating the price on the client side and server side. Yeah, so that's something just to be super aware of is anything on the client side can be changed and will be changed by malicious actors. So don't trust it being sent in from from the user. Same thing with like, like, what was I saying, like if you're like, take the request dot body and express and you're saying, Oh, this is this is server side. But if you're just like taking the entire payload from the user, and then saving that to a database, the user could send any data that they want. And you could just immediately say that to your database. And that could that could also be like overwriting private fields, like privileges, which you don't necessarily have access to on the client side. So be very careful about that. Don't trust the client?

16
00:13:27,749 --> 00:16:42,270
Scott Tolinski: Yeah, yeah, I checked my types every step of the way. I check them before they're inserted into the database, I check them when they're coming from the client to the server, you know, you got to check all check all that stuff all the time, clean it, sanitize it, whatever. Last thing I want to talk about really quickly here was PCI compliance, which if you're doing any sort of e commerce, accepting of credit cards, accepting a payment, PCI compliance is very important because you can get into big trouble for not following these things. And largely, if you're following best practices, you will be PCI compliant. There's a lot of server side components to this. But there are some client side components as well. For instance, we mentioned very, at the front of the show that we wanted, you always need a secured encryption of sending your data. And obviously, if you're sending credit card information down the line, you're going to want to make sure you definitely have an SSL. So do you encrypt your plate your cardholder data, there's also the option of doing like a secure iframe. I know stripe and Braintree have a solution where they have an actual secure iframe. But I would just also have an SSL anyways. So those are options. If If you don't want to construct your own form or have to deal with security for credit card data, I would just use the stripes or brain trees solutions for those anyways, simply just because they already have all the best practices worked out for you. Next, again, you're going to want to encrypt transmission of card or cardholder data, okay, along with the SSL stuff. That's all for free. If you have an SSL, you also want to restrict access to cardholder data, your API like you shouldn't be able to Hit the API and say, Hey, give me West, Wes Bos, his credit card token and all of his, you know, expiration date and information and stuff that your API should say, Nope. And that's obviously a server side thing where your API but also if you're using you build your your graph qL API, you just got to be sure your your REST API that that information that's coming down the line there is what you would expect it to be is that is more server side. When I wrote this, I was thinking client side for some reason. Next up, we have restricted physical access. This is this is actually I have a personal story about this, we were redoing this website for this monk company. And we were talking about PCI compliance. And they were really annoyed at the new sort of way, they had to do everything. They were just like, Oh, I have to check the order. Is this in the system? And I got to do this and the system now? And we're like, Well, yeah, but how did you do it before because this is how you have to do it. They're like, well, the credit card would just come to me via the website, and I would write it down on a notepad. And then I would walk over to the machine and I would type it in. And then I did Enter. And we were just all standing there, horrified. Like, you mean, the credit card information is coming in as a string in plain text via email to you. Oh, my lord. So we, we fix that up real quick. And they weren't, they weren't happy with the new system, because it added all these extra steps. But these extra steps were very important. Like that was a horror show to me, I couldn't believe what they were doing. So the do all these things in no help you remain PCI compliance. But at the end of the day, all of this stuff follows the same sort of pattern that we've been talking about encrypted, don't trust it, sanitize it, clean it, all that good stuff.

17
00:16:42,390 --> 00:18:21,830
Wes Bos: Yeah, I've one more little tip here. And that is if you have like a form input, or you have a form, and that has like sensitive fields, a credit card or password or something like that, I mean, you're doing that with like a JavaScript framework, or what I often see is people forget to put a method on their form, because you just you just have a form tag, and you say on submit, and then you send it. But what happens is if JavaScript is for whatever reason, JavaScript breaks, the form tag will default to a method of get, and a method of get will put the inputs that have a name attribute on them, and we'll put them in the URL bar. So if you accidentally forget to put a method and you put a name on your inputs, and somebody submits that form, what will happen is that the user's URL bar will will submit that data and then it will say like, at the end, question mark, credit card equals ABC 123 ampersand password. And then what you've done there is is one you've, you've pushed the user because now their password and credit card is in their browser history, which may be may be logged by analytic companies, it may be a public computer, it may be in server logs, meaning that like somebody just said, like somebody requested this, and then it all sudden, you have sensitive data in your server log. So as a rule of thumb, I never put a name input on sensitive fields, I just use JavaScript to grab them some other way. And then and be always put up POST method equals post, just in case something breaks. And you sort of cover yourself there. Because obviously posts won't go into the URL bar. And you can you can unless you're logging all of the posts variables that probably won't go in your logs either.

18
00:18:22,100 --> 00:18:44,090
Scott Tolinski: Cool. Well, I think that does it for this episode, we want to hear what you do for front end security. I want to hear all about the some of the stuff that maybe we missed or didn't cover in this episode that you think is important for front end and security. If you tweet us out at syntax FM, we will retweet you some six security tips for the front end. Cool. So that's all I got. How about you?

19
00:18:44,300 --> 00:19:36,930
Wes Bos: I think that's it, I just want to say we intentionally didn't get into HTTP, local storage tokens because that's a dumpster fire of people arguing but generally, maybe just real quick, the sort of hot and certain skinny of it is is that if you are using JSON Web tokens, you can put them in cookies, and you make that HTTP only cookie and then that can't be accessed by JavaScript, meaning that if a rogue person does get the ability to run JavaScript on your page via the inner HTML we talked about, then they can't access that. If it isn't local storage, then you're poached. And that's why people don't like putting JW T's in local storage. We have a whole episode on the pros and cons of the two of those. I personally use cookies, but I don't really, I think that if you have somebody running JavaScript remotely on your page, you're you've got big problems, and one of them is that they can see your token.

20
00:19:37,290 --> 00:19:38,610
Unknown: Yeah, yeah,

21
00:19:38,610 --> 00:19:44,490
Wes Bos: I think that's it. Yeah. Thanks for tuning in. We will catch you on Wednesday. Please

22
00:19:46,440 --> 00:19:56,220
Scott Tolinski: head on over to syntax.fm for a full archive of all of our shows. And don't forget to subscribe in your podcast player or drop a review if you like this show.

