1
00:00:00,359 --> 00:00:24,149
Announcer: Monday Monday Monday open wide dev fans yet ready to stuff your face with JavaScript CSS node module BBQ Tip Get workflow breakdancing soft skill web development hasty as crazy as tasty as web development treats coming in hot here is Sarah CUDA, Bob and Scott Tolinksi

2
00:00:25,890 --> 00:00:47,340
Scott Tolinski: Welcome to syntax in this Monday tasty treat. We are going to be talking all about react suspense and largely about the future of react as we talk a little bit about the roadmap here of what we're going to be seeing out of react over the next few months here and how it's going to evolve now My name is Scott winsky. And with me as always is Wes Bos,

3
00:00:47,460 --> 00:00:48,840
Unknown: everybody. Hey, Wes.

4
00:00:48,990 --> 00:03:14,610
Scott Tolinski: This episode is sponsored by one of our favorite sponsors over here, which is Sentry. Now Sentry is a great way to track all of your bugs, and let you be aware of the things that are happening on your site. Like right now, I just pulled up in my Sentry dashboard, I see an error here cannot read property name of null, which means that I probably forgot to check to see if something existed first. And now that's something I'm going to want to take care of immediately following this, this podcast recording episode and, and one of the cool things is that Sentry allows me to do is immediately mark that as a GitHub issue, track it and make sure it is completed in the very next pull request. The next deploy century@sentry.io again, is something that you're going to want to try. And to give Sentry a try, you're gonna want to head to sentry.io and sign up using the coupon code at tasty treat all one word, all lowercase, and you will get two months for free of Sentry. And definitely check it out. Because it's one of these services if you're running software that other people are using, you're going to want because when you hit bugs like this, your users aren't going to tell you that the bug I just mentioned, I haven't had a single person tell me that they've hit that bug. However, I can see that a certain amount of people have hit that bug already. So I'm going to go ahead and fix that. And no one's going to have to tell me to fix it to do it other than Sentry, so against sentry.io. Use the coupon code tasty treat and check it out. Cool. So without other way, let's get into suspense. Because we've done an episode on hooks, and no suspense could potentially once it's been released, we should probably do maybe a full episode on it and explain our episode where we talk all about the ins and outs of it. But this is going to be a little bit more about high level what it is how it's going to improve your life and where reactor is going to be going over the next few months. So there's a really great react blog post by Dan Abramov published November 27. About the React 16 roadmap. And this thing is really great, because it really gives you a big insight into what the team is thinking and where it is going. Now, you will see that obviously hooks has been released, we talked about hooks. But even before that in version 16.6, there was a suspense for code splitting, which we're going to be talking about as well. And then they have in q2 2019, concurrent mode, and then mid 2019, suspense for data fetching. So these are all things we're going to be hitting on in this episode a little bit, give you a little bit of what the problem is, what problems that's trying to solve and how they make your life better.

5
00:03:14,730 --> 00:05:30,630
Wes Bos: Yes, we should say that this is all going to change and might change. So because it is not yet released, what we say here on this podcast may change. And we just want to give you that warning that because we're talking about something that will come to react at some point, it is likely that some of the packages, some of the API's, I even had done a talk on react suspense, and then the API totally changed. And that's to be expected with this sort of stuff. It's not something you're going to be putting in your putting in your production application. But it is nice to know about what's coming this year in terms of react, what's going to change and what why are we getting these things? So why don't we first kind of get into the sort of problem that we have with react that react suspense is going to attempt to solve, and I'll do my best to sort of explain how it works. So generally, you have components in your react application. And those components need to load data, they need to fetch an API call, they may need to load an image, they may need to load some sort of code split bundle that is out there. All of these things happen synchronously, meaning that they they happen sort of in the background, and then when that data comes back, it will be set to your component you put into state somewhere, right? And that's great. Except that when that data is being fetched, we have to show some sort of loader, right? Because we have to show some sort of UI, like what do you show to the user when that data is being fetched. And generally, that just means some sort of spinny spinner son that is being put on the page, right? And one problem that we have in react is that where you fetch your data, and where you show your your loading UI, generally will happen. in the same spot, because if a component fetches its own data, it will also have to maintain its own loading state internally, instead of like sorry, another option is you can put all the stuff at the very top of your application, where that's where you maintain your loading state. And that's where you maintain your API calls. And if that's the case, then you have to pass the data all the way down. So it kind of two approaches to it. And both of them make it kind of hard to figure out where you should show your loader and where you should be fetching your data. Yeah, I

6
00:05:30,630 --> 00:06:49,620
Scott Tolinski: think we should state that the problems that these are trying to solve is really just trying to make our data fetching, more seamless. Our applications load to the user, like the perceptive loading time for applications, the perceptive loading time faster, as well as do things like code splitting, again, to make our bundles smaller, all of these things are going to make your apps render faster, better, stronger, all of those things, in a way. Yeah, I mean, it's def punk up in here. And I think that I think this mess is gonna be a game changer in that regard. React hooks have been amazing as the nice little update. But I think suspense along with the libraries that eventually will take advantage of suspense, are going to really change how your applications load and function. And I'm personally really looking forward to a ton of this stuff, because a lot of it is solving problems that are difficult problems to solve. And the React team makes them wants to make them easy, because if code splitting is easy, if it's painless, if it's the way to do things, then everyone's going to code split, and your site's going to load fast. If concurrent rendering, which we'll get into a little bit more as well, is easy, then people are going to use it. So again, I think the team is really just taking steps to make our applications load faster and be better for your users and make it easy on us to do. So

7
00:06:49,830 --> 00:07:08,280
Wes Bos: I'm really excited about these changes, because it makes both your users lives better by providing them with better feedback as to what's loading. And we'll talk about what they all are. There's there's pre loading available via caches, as well as it makes our lives the developers easier. And when you can do both of those. Were in a good spot.

8
00:07:08,880 --> 00:07:11,880
Scott Tolinski: Yeah, that that is the ideal situation right there.

9
00:07:12,180 --> 00:09:14,880
Wes Bos: All right, so let's get into what react suspense is. So again, the let's let's imagine that we have a user component, and that component needs to hit an API, fetch data about the current user and then come back with that data, and then put it into state or somewhere and then display that data, right. That's something we've all done before. And previously, what you might do is on component mount, you fetch that data. And then you set a loading Boolean to true. And then when the data comes back, you set that user data back into state, and then you set the loading Boolean to false and you go ahead and render out whatever it is that component wants to render. So the the idea was Spencer's got a whole bunch of like points here, we'll we'll kind of go back and forth on them is, first, what you want to do is you take your your data fetching function, so maybe have a function that's like a sink, get user info, and that goes off and fetches an API doesn't really matter how you fetch your data, as long as you are, you're going off some way to get some sort of data, you turn those functions into what are called resources. So react will ship an API called create resource or something like that. That's what's called right now. And that turns your sync functions into what are called resources. And then what you have is with these resources, you read these resources right above your render. So imagine that you have a user component that displays the name and a profile photo for that user, what you would do is right before you return that JSX with an h2 tag and an image is you would simply just take that resource, and call dot read on the resource. And what that will do is it will sort of synchronously, like it won't block behind the scenes, that JSX in that component will not render until that resource has been resolved or fully read. And that's pretty cool. Because you don't have to worry about loading Booleans. In this case, you simply just say like const, user equals user resource dot read, and then it will go off, fetch it come back. And then you have a user variable, and you can go ahead and use it right,

10
00:09:14,900 --> 00:10:02,300
Scott Tolinski: yeah. And then so your resources can then be read from a cache. Now, the cache that comes that react will ship will just be a basic react cache. What's cool about that is that libraries like Apollo relay, and any of these other data fetching libraries can integrate into suspense, which I know is something the Apollo team is very interested because they did talk about it. And they'll be able to utilize the cache in the same sort of way. And really just integrating these systems in, I don't know, much more seamless way. And so resources can then be also pre loaded into the cache anticipating when you need them. It's basically going to make the caching of your data, it's going to make it more integrated into react because right now, we all know that libraries like Apollo and relay, they do their own caching, but now it's going to Be more tightly integrated into react?

11
00:10:02,460 --> 00:11:12,360
Wes Bos: Yeah, I would, I would imagine that like Apollo will roll their own cache, and you simply just read from the Apollo cache. Because right now there is the only cache that I know of is called react cache. And there's no docs for it at all. It's a totally separate package. And that's intentional, because like, I don't think that will be the, the cache because there's, I don't think there's any information as to when it should expire, or how to refetch data, if it goes stale. But that's the sort of idea is that you will be able to take your resources and read them against the cache. And if there's nothing in it, it will do the network requests. And there's also pre load functionality as well. So you can call dot preload, you would imagine, yeah, you could, if you're on like a user, and you want to like pre load the next three users so that when someone swipes over to them, they will already be read. That's great. Because then your user component doesn't care about whether you need to preload it or not. It simply just reads it from the cache. If it's not, there, it goes and gets it and it takes a an extra second or two to fetch the data. And if it's there already, then great, it'll immediately return it into the user variable, you don't have to worry about pre loading or states or anything like that. Yeah,

12
00:11:12,390 --> 00:11:33,990
Scott Tolinski: it's funny, because that's one of the things that makes Gatsby so great is like the automatic pre loading that's in Gatsby right now. It's one of the things that makes us so fast. And again, Gatsby does a really great job of making these things easy, and we don't have to think about them. So it's really great that the React team is going to be making these things easy overall, because when it's easy, everyone's gonna do it. And again, it's going to speed up all of your stuff.

13
00:11:34,140 --> 00:13:55,440
Wes Bos: So let's talk about loading state. Now, I just said that you can have a user component, it reads the data, and then it displays it. Like what about that sort of in between time where between fetching the data and displaying it? If there's no logic inside of your user component? How do you decide what to show the user? Like? Does it just show an empty JSX? state? Or does it show like, I remember back in the angular days, you would just see the actual Angular templates for a second before your data loaded? Like, what do you do there. And in this case, what you do is you take a suspense component. So this is going to be a new component that ships with react core, you import suspense from react, and then anywhere higher up in your, your tree. So anywhere on your page, you can wrap your components in a suspense component. And then that suspense component is smart enough to know that some of its children, one or many of us, children's anywhere down the road, children on the road, fetching data, yeah, children along the road, it knows it without having to communicate or send data between those two components. It knows if any of its children are currently fetching data. And then at the suspense level component, you can choose two things you can choose, what should I show? When we are currently in in a loading state, you can simply just pass it a loader prop. So you say like fall Spence. Oh, wait loader, though used to be called fallback. Now? It's, oh, no, no, I think it's called fallback. Sorry. You're right. It's called fallback. And that is the component that it should show when you are in loading state. And then the other one is a max delay prop. And that's how many milliseconds should we show nothing. And that's good for fast connections, meaning that like, have you ever been on a website with a fast connection, and you just see like, like six or seven loaders really quickly. And then as the data populates, it sort of rejects. That's bad UI. And it also could hurt your if you have any animations going on on your page, that triggers of re renders can hurt animations on your page. So this will just show nothing, you can say like max delay, 500 milliseconds, and if all of your data takes less than half a second to fetch, then it will just simply render out nothing to the page. And then you get that nice clean single render on the page. And that gives the idea of perceived performance. It's not actually making it any faster, but the UI is a lot nicer.

14
00:13:55,470 --> 00:14:45,750
Scott Tolinski: Yeah. And we'll talk a little bit more about this when we talk about the suspense for data fetching, but I'm already doing this kind of thing with react loadable, for lazy loading components, where you do give it this delay time to make sure that, hey, we're not showing a spinner while it's loading this component if you don't have to. And the brilliant thing is, this is all going to come into data. And again, if you want to show a spinner, you can show spinner. If you want to show a skeleton screen, you can show a skeleton screen, there's a lot of options here in it, and I think is really going to open it up. It's going to make a lot of this stuff very easy. No more if loading, show loading animation. And then you know, if data is ready, then blah, blah, blah, it's just going to be able to handle that for you. So fall back prop is going to show you your loader as long as it's within those bounds. And until your data comes in, and it's just going to handle it automatically for you.

15
00:14:45,840 --> 00:14:53,010
Wes Bos: Yeah, that's like every component I write if loading show loader if error, show error, right. Otherwise, show the actual component. Exactly.

16
00:14:53,250 --> 00:16:51,960
Scott Tolinski: Yeah, so I'm really excited for all of this again, what I'm most excited for is the impact is going to have on the libraries that we use every day. The ways that we fetch data, and the ways that it's going to load the controller is going to give us. And so we talked a little bit about react suspense for data loading, which is really sort of the last thing in the roadmap. Here, they're saying this is going to be like second half, or mid mid 2019. So suspense for data fetching is mid 2019. But before this lands in react two, there are some things that needed to land and react first. And the first of which is already shipped, actually, which is suspense for code splitting. And it launched with a couple of caveats, which is why I'm not personally using it right now. But suspense, for code splitting functions very much like what we have for data fetching, where you have a suspense component that wraps around your components. And then you use something called react dot lazy to import something now, through this lazy importing, it's not going to import or even load that code in your bundle until it needs it. And so it's going to have to do a network request to go fetch that bundle of code, it's going to have to use a potentially used a fallback if the network request is taking a little bit of time. So same thing we have a fallback prop with maybe it's a loader, maybe it's the skeleton screen or something. And what it does is it gives you code splitting very, very easily. Now, why am I not using this right now, I'm not using it right now, because it doesn't currently work with server side rendering. The good news is, is that Meteor has its own import dynamic import system. And I'm using that plus react loadable to get the same functionality with server side rendering. But the React team recommends loadable components for server side rendering, if you aren't, if you need server side rendering and would like to use dynamic imports in code splitting. So until that SSR, stuff lands, I probably won't be using this one either, either. But suspense for component loading with the code splitting stuff is again, it's taking something that's a problem and making it really, really easy to fix.

17
00:16:51,960 --> 00:17:37,100
Wes Bos: So yeah, you can use that already today. In your code, if you want to try it out, you can just look up the docks for react dot lazy and that will lazy load your code and maybe should real quick explain what that is. If you have a component that has a bundle of JavaScript, like a shopping cart, and that shopping cart, needs to load that JavaScript before work, instead of just loading it on the homepage, because the shopping cart might not necessarily be needed ever, or until someone adds the item to the cart. You can lazy load that on demand. So when someone clicks something to add to cart when someone visits the cart page, or you can just like anticipate somebody doing it. So once the page is fully been loaded in, someone's just sitting there watching a video or something, you could in the background preload that little bit of JavaScript in their

18
00:17:37,740 --> 00:18:15,320
Scott Tolinski: word. So the So okay, so code splitting for suspense hasn't been launched, it's been added, it's already shipped, with the exception of SSR. Then Next came the next release that we mentioned was react hooks. Now, I don't think hooks has too much to do with suspense. But the next one here, which was concurrent mode has a lot to do with suspense. Now this was originally called async mode, they changed name became current mode in what the heck of async, concurrent I mean, they're kind of long, jargony words, it really just means that your application is able to load things without blocking, right, it's able to load things in parallel jumping from component to component rather than just going right down the list.

19
00:18:15,540 --> 00:18:20,550
Wes Bos: Yes. And someone's going to get real mad that you said parallel there. There's a funny thing in JavaScript.

20
00:18:20,570 --> 00:18:21,300
Unknown: Yeah, okay. Well,

21
00:18:21,300 --> 00:18:27,390
Scott Tolinski: I don't mean it in programming. But because it's so hard, it's a parallel.

22
00:18:29,040 --> 00:18:38,060
Wes Bos: Yeah, parallel is so much more easy to understand. Whereas in reality is JavaScript is concurrent, not parallel, and someone's gonna come in, I'm gonna

23
00:18:38,060 --> 00:18:42,270
Scott Tolinski: knock down your door, I'm speaking specifically about the literal definition of the word.

24
00:18:44,580 --> 00:19:09,180
Wes Bos: So that should come out q2 2019. Apparently, that is something that needs to land inside of react before we can get suspense in. So pretty exciting. next couple of next six or so months in, in react world, I think that it's going to it this is not going to break anything that you've done before. But just just like hooks did to, to our components thing is going to make the developer experience much nicer

25
00:19:09,450 --> 00:19:57,240
Scott Tolinski: word. So all these things combine like Voltron to form what is the future of react, and we are they're gonna form like, Voltron, I believe is the Wu Tang lair. But yeah, so we are looking at a very bright future of react data fetching, loading, making our apps fast, smooth, available to the user in a way that makes them happy. These are all great things. And you should be very excited about all this stuff. I'm very excited about all this stuff, as I always am, I suppose. But yeah, keep looking out. Check out the React blog posts, check out the the documentation. Keep in mind that this stuff, again, like we mentioned is not exactly finished. You know, you can see some of the launch dates are mid 2019, for suspense for data loading. And, again, you just want to keep that in mind when looking over any of this documentation.

26
00:19:57,420 --> 00:20:19,890
Wes Bos: Yeah, the ones that comes out, we will start to see See the same thing with hooks hooks has been out for a couple weeks now or maybe even a month. And we're just starting to see some really neat implementations of it. So probably a month or two after suspense drops. We'll see what the community has done with it and we'll probably have a full show on it. Just explain what it is and the different ways that you can use it.

27
00:20:20,130 --> 00:20:33,240
Scott Tolinski: Absolutely. I look forward to that. I look forward to using suspense. I look forward to learning more. I look forward to getting flamed on Twitter for the things that I said that were incorrect in this. fixing it for the next one, but I appreciate it.

28
00:20:33,930 --> 00:20:39,560
Wes Bos: Awesome. Alright, that's it for today. Thanks for tuning in and we'll catch you on Wednesday, who's face

29
00:20:41,550 --> 00:20:51,320
Scott Tolinski: head on over to syntax.fm for a full archive of all of our shows. And don't forget to subscribe in your podcast player or drop a review if you like this show.

