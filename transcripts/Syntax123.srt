1
00:00:00,359 --> 00:00:24,450
Announcer: Monday Monday Monday open wide dev fans yet ready to stuff your face with JavaScript CSS node module BBQ Tip Get workflow breakdancing soft skill web development hasty as crazy as tasty as web development treats coming in hot here is Sarah Kuda, bars and Scott Taylor. Totally at ski.

2
00:00:25,950 --> 00:02:06,660
Scott Tolinski: Oh, welcome to syntax. In this episode, we're going to be talking about authentication, which is something that so many websites have. And in particular, we're going to be talking about how to use and when to use things like local storage, verse cookies versus sessions, verse tokens, and sort of dive into what all of that means, and maybe illuminate some of these things that you have to deal with when dealing with authentication. Now, this episode is sponsored by Log Rocket. Now, if you've been listening to syntax, you've probably heard us talk about Log Rocket before, Log Rocket is an amazing service to allow you to gain full visibility into your bugs. And when I say full visibility, oftentimes, we get like stack traces, and we get code outputs and error logs. And that feels like full visibility, but you haven't had full visibility until you've had full visibility. What I mean is, with Log Rocket, you get a session replay, which is a video showing you exactly what the user did. It gives you access to the network requests, it gives you access to your Redux store, it gives you access to any sort of console errors or logs or anything that's happening on your sight. So not only do you get the stack trace sort of stuff that you typically get, but you get the default on experience of what exactly happened. And let me tell you, there's nothing quite like this visibility. So check it out at Log rocket.com forward slash syntax and sign up there, and you will get 14 days for free. And it's only gonna take 14 days to have one bug pop up and check out this insane visibility. So check it out Log rocket.com forward slash syntax. So authentication, yeah, some introductions here. My name is Scott Delinski. I'm a developer from Denver, Colorado with me, as always is Wes Bos. Hello, hello.

3
00:02:06,660 --> 00:02:07,980
Wes Bos: How you doing? Doing good.

4
00:02:07,980 --> 00:02:24,600
Scott Tolinski: doing real good. I'm not sick this week. Even though I do have a lingering cough, it seems to not go away. So hopefully, I don't sound sick. And I apologize for last week's episode, where I was definitely sound a little under the weather here. But feeling good. So let's get into it. Where do you want to start here?

5
00:02:25,220 --> 00:07:30,060
Wes Bos: Yeah, so we got this question via our potluck that says, authentication versus cookies versus sessions. And I like this because it's it's kind of a broken question where these things aren't necessarily versus you might be reading the title and being like, oh, local storage is not something like vs. cookies or tokens might not be vs sessions and things like that. So we thought we'd do a quick explainer episode breaking down sort of these two ideas that we have here. And hopefully you can walk away knowing exactly how they work. A lot of times, I think that you're going to be using a framework or something that has this stuff built in under the hood. So you might not necessarily know which one you're using. But then when it comes time to maybe like integrating something like Apollo into your application, you You do have to write a little bit of middleware that will sort of take the authentication along for the ride so that your requests actually are proof. So understanding and being in the headspace as to how these things work, I think is pretty important as a front end developer. Absolutely. So let's break it down into I like to break it down into two different questions here. So first one question is, what should we do to track our user? So it should we use JW t, which is JSON Web tokens. We've talked about jvt a lot in this podcast, you can go back to some of the previous episodes and listen to that. So we're not going to go super deep on on how all that works. But we will go into it a little bit. So how should we track our user JW t JSON Web tokens or sessions? And the second question we have here is how do we identify each user on request? Meaning that when you make a request to a server, does the server know about you already? Or do you have to send something along to authenticate yourself. And that's generally broken down into two popular ways in the browser is one is via storing a token in local storage. And then the second is either storing a session ID or that token as well in your cookie. And we'll talk about the benefits and downsides to it. So we'll start off with the first one that we have here, which is how should we track our users JW T or session. So let's just explain sort of how both of these JSON Web tokens and sessions work right now. So let's assume you are signing into a web application. Generally how that works is you take a username and a password and you post that data to an endpoint on your server with the username password that will come back to you with either a success or sign that broken assuming it was this access. What that will do is it will come back to you with a JSON web token. And that JSON web token is just a seemingly random token. Although if you were to decrypt a or not even decrypt, if you're just uncomfortable, The token, you can see that there's generally a user ID and you can store some information in there. Once you have that JW T is store that JPG somewhere. And that token can be stored generally, it's stored in local storage, it can also be stored in a cookie, we'll talk about that in a second. And then upon every single request, you must send along that token for the ride, as it is your sort of ticket to getting past into authenticated areas, the cookie based approach is somewhat similar, you generally log into a website, you ping a back end either via an AJAX request or just a regular POST requests with a form. And then what comes back from that is not a token, it's just a response that says it was successful, or unsuccessful. But the key here is that on the rebound of that, generally, we'll set a cookie that has a session ID in it, and that session, Id will identify you on the server, and then any other requests from there, we'll be able to have that cookie along for the ride. So so far, it makes sense. It makes sense. Yes. So token, what's the benefits and downsides to tokens versus sessions token based authentication is stateless tokens are probably the the newer version of the two sessions have been around forever. And token based authentication is stateless, meaning that you don't need to maintain a list of logged in users on the back end server. And that's really helpful because often people are deploying their website to many serverless functions, or they're deploying micro services to many different servers. And if that's the case, you don't have to maintain like a database of users that is shared between all of these things, which is great. They can be cross domain. Again, if you're if you're running services across many domain names, that can be helpful. You can store data in tokens, like a user ID or some of the user's preferences in a JW t token. And then finally, I think it's it's really easy to use on like non web sites, meaning if you have like a mobile app, they want to use with your graph qL API, there's no concept of like cookies in a lot of these sessions in a lot of these mobile apps. But you can just send a long string of text that is a JDBC token. Finally, the one downside to jadibooti is it's hard to expire them on a session based, you can just delete the session, and that user is just logged out. The only real way to log a user out with tokens is you have to maintain like a blacklist of people who will not be able to and then you have to add some filtering. Or you could just change your your algorithm for generating these tokens. And if that's the case, then everybody gets yanked out which

6
00:07:30,090 --> 00:07:45,450
Scott Tolinski: Yeah, which sucks. Yeah, it's like a sort of a blanket solution to that just log everybody out. But again, I guess that could be useful in some particular situations. But most often times if you're trying to just ban or lock someone out, that's not going to be the best idea.

7
00:07:45,600 --> 00:09:33,840
Wes Bos: No, no, not at all. So the flip side is using session based authentication. And generally, this is popular where server rendered applications, we talked about how they work sessions are stateful. So you generally need to maintain a list of session IDs. So this is probably if you've ever learned no jazz before, you've got sessions up and running. But then when you kill your server and start it up again, you're logged out and you go, huh, why did I get logged out. And it's because what was happening is, by default, a lot of these like passport jazz, they will just maintain a list of sessions in memory. And when you kill your app, all of that memory is cleaned up. So then you have to get like an adapter and store a list of all those sessions in your database. And then make sure that you remove them when the session is destroyed when somebody logs themselves out. Or if they're expired after a certain amount of time you have to run a cron job and clean them up a benefit to Sessions is that they're passive. And what that means is that once you are logged in, you have a cookie set in your browser and any other requests to that server will automatically the cookies come along for the ride for free. Whereas local storage needs to be actively pulled out pulled out of local storage and then put in so one huge benefit to using sessions and cookie based approach is that your first render can be the logged in view. So if you have a react application, and this is true on my advanced react and graph qL, we use JW T, but I put them in a cookie. And the reason we do that is so that when you go to the website for the first time after already being logged in, that token comes along for the ride, whereas sometimes you go to a website, and you get the logout view for a second and then it goes to flashes, and then you get the logged in view. That's because they loaded that first view. And then they realize that you had Oh, there's something here in local storage. And then they sent that over to the back end and came back and had to re render the login view that you

8
00:09:34,110 --> 00:10:09,650
Scott Tolinski: know, it's funny because I just I mean I do similar. I don't have my token stored in a cookie for server side rendering. And so a lot of those things I just default to say, if you're logged in these particular things, just ignore them entirely for server side rendering. And that's only because I just to be honest, I haven't had the time to set up the auth or server side rendering component of my my stuff so I definitely feel that aspect of it. Were just certain components of my website aren't server side rendered, just because they require some sort of user thing. And I do a little bit of a pop here and there on some items.

9
00:10:09,750 --> 00:14:24,450
Wes Bos: Yeah, that we should be clear here is if you want to do server rendered JavaScript, when a user is authenticated, or user has specific UI for whoever they are, you cannot do that with local storage approach. Because low there's no way to send local storage to the server on every single request, you have to you have to use JavaScript to send it across. It doesn't just happen for free, like it doesn't cookies, right. So that's not a huge deal for a lot of people. Because once you load the app once, then you have everything there. But for other people it is. So that's the first little bit which is how do we track the user? Do we use JSON Web tokens? Or do we use sessions? The second question is, how do we identify each user on each request, we kind of already went through this as well, local storage or cookies. So with local storage, you need to grab the token and send it along for every request with with cookies that is sent along on every single, every single request. So cookies is much more implicit, where it just comes along for free tokens are more explicit, although in almost all use cases, you're going to have something like Apollo middleware, or you can set up a special fetch request. And as part of that request, it will just automatically grab it from local storage for you. So it's not like something you have to code into every single request for you. Last thing I want to note here is just security issues. There's lots of debate on either side, should you use tokens, or should you use sessions, what's the better approach? So the security issue with a JSON Web tokens is that is x SS security issue, and that means is a cross site scripting, what that means is that when somebody else is able to run JavaScript on your domain, then you're in trouble. Because let's say you had like somebody from bad website.com. And they were able to somehow run some JavaScript on West boss calm, as soon as they're able to run JavaScript on West boss calm, whether that's a rogue Chrome extension, or whether that's a just an image that was loaded inappropriately, or in most cases, when people don't sanitize their inputs, then that person is able to reach into your local storage, because it's all client side, read that token. And now they have access token. And they can start running requests from from wherever they want. So the way that you sort of combat that is making sure that you don't let excess happen. Some some of the sanitization happens for free in react and Angular, if you've ever come across the method in in react called dangerously set inner HTML. That's, that's why it's called dangerously set inner HTML, because you generally shouldn't put HTML into an element and then parse it into the DOM, unless you are first running it through like purify Dom or something like that, unless you're actually first sanitizing it. And the next one with Sessions is excess RF cross site request forgery. And there's a whole bunch of YouTube videos that will explain this, there's a general you need a lot of like visuals and graphics to understand how this works. But generally, the way that it works is that someone could actually get access to that session ID, or someone could, someone can run a request from from their website onto your website. And if you don't have things in place, then they can actually trigger malicious actions from a separate domain name. So Case in point, if I were to, like if Scott has like an endpoint on level up tutorials that says, pay West $1,000. And Scott was logged in to the system and he were to visit my website, because he's logged in and has the the cookie for level up tutorials in his browser, I could trigger a request to his own domain from my domain, and then that would trigger the sending all of the money to me, right. And that's sort of like, that sucks, because your hands are sort of tied behind your back. And that means that other websites can trigger requests on your website. And the way around, that is this thing called CSRF, which is these unique tokens, you'll generally find them in hidden inputs on a form field. So there's downsides to both you should be aware of what both of the both of them are. I'm by no means a security expert here, but it's probably worth going and watching a couple of YouTube videos as to how both of these things work just to be aware of potential issues if you're rolling your own system like that.

10
00:14:25,650 --> 00:14:28,080
Unknown: So yeah, well, yeah, I'm

11
00:14:28,080 --> 00:14:31,710
Scott Tolinski: gonna give you a round of applause here. That was an excellent little explainer.

12
00:14:31,890 --> 00:15:07,680
Wes Bos: Cool. So hopefully, that that clears a few things up. Now, what should you use, it really doesn't matter too much. But generally, if you are building a react application with your own custom back end, or even if you're using some sort of other back end, a lot of these things are using JSON Web tokens. If you have a more traditional back end, you probably will be using session. So my learn node course uses sessions, and then my advanced react and graph qL uses JSON Web tokens just to show how both of them work. Although both courses use cookies instead of putting it into local storage, and the reason is because I want the server rendered off on both of them.

13
00:15:07,890 --> 00:15:29,370
Scott Tolinski: Mm hmm. Cool. And all of this stuff scares you. There's always things like passport j s auth. Zero, what other auth. I know Netlify has their identity auth platform. So if all of this stuff scares you, there's definitely other ways to go about this. And using services that might take some of the some of the guesswork out of it for you.

14
00:15:29,610 --> 00:15:57,030
Wes Bos: Yeah, yeah, you look for something like auth zero, they will run the JavaScript side for you, as well as they have packages for your server side. And they will take care of setting it all and all the cross domain stuff. Because it's it's pretty tricky stuff. I think that's where jazz won't do any of that for you passport, j S will just actually generate the tokens or generate the sessions for you. And then you still need to set them into into a cookie or store them in local storage on every single request.

15
00:15:57,090 --> 00:16:06,870
Scott Tolinski: Yeah, there's certainly various levels of assistance, right? Between like, even services that will do it all for you to ones that just help you out here and there. So cool.

16
00:16:07,080 --> 00:16:16,230
Wes Bos: Yeah. So if you've got your own specific way of handling authentication or your own service that you prefer, make sure you tweet us at syntax FM. Anything else to add here, Scott?

17
00:16:16,620 --> 00:16:19,050
Scott Tolinski: I got nothing. No, that was a very informative West.

18
00:16:20,220 --> 00:16:25,470
Wes Bos: Awesome, go. Thanks for tuning in. We will catch you on Wednesday. Cool, please.

19
00:16:27,690 --> 00:16:37,470
Scott Tolinski: Head on over to syntax.fm for a full archive of all of our shows. And don't forget to subscribe in your podcast player or drop a review if you like this show.

